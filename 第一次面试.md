1.jsp页面的9个内置对象：(jsp也是一种模板引擎)

#####   1.request    

​          HttpRequest   setAttribute() 、getAttribute()

​            (1) String getMethod() //获得提交方式
​           (2) String getRequestURI() //获得请求的URL地址
​           (3) String getProtocol() // 得到协议名称
​           (4) String getServletPath() //获得客户端请求服务器文件的路径
​           (5) String getQueryString() //获得URL的查询部分，post方法获得不到信息
​           (6) String getServerName() //得到服务器的名称
​           (7) String getServerPort() //获得服务器口号
​           (8) String getRemoteAddr() //得到客户端的IP地址
​           (9) String fetParameter(String name) //获得客户端传给服务器的name参数的值*

#####   2.response 

​           HttpResponse  addCookie()、getWriter()

#####   3.session    

​         HttpSeesion     setAttribute()、getAttribute()

#####  4.appliContext

​               ServletContext()  setAttribute()、getAttribute()

​            application 对象是javax.servlet.ServletContext类型的对象，可将信息保存在服务器

​             中，直到服务器关闭，否则application对象中保存的信息会整个应用中都有

#####  5.config 

​           ServletConfig    getInitParameter()、getInitParameterNames()

​        config 对象是javax.servlet.ServletConfig类的实例对象。主要作用是取得服务器的配置 信息。通过 pageConext对象的 getServletConfig() 方法可以获取一个config对象。当一个Servlet 初始化时，容器把某些信息通过 config对象传递给这个 Servlet。 开发者可以在web.xml 文件中为应用程序环境中的Servlet程序和JSP页面提供初始化参数

##### 6.exception 

​         Throwable  getMessage()

##### 7 page Object

  page 对象代表JSP本身，只有在JSP页面内才是合法的。 它是java.lang.Object类的实例化对象。page隐含对象本质上包含当前 Servlet接口引用的变量，类似于Java编程中的 this 指针

##### 8.out JspWirter            

​           write()、print()

  out 对象用于Web浏览器内输出信息，负责管理对客户端的输出。并且管理应用服务器上的输出缓冲区。在使用out对象输出数据时，可以对数据缓冲区进行操作，及时清理缓冲区中的残留数据

9.pageContext pageContext   setAttribute()、getAttribute()

 pageContext 对象的作用是取得任何范围的参数，通过它可以获取 JSP页面的out、request、reponse、session、application 等对象。pageContext对象的创建和初始化都是由容器来完成的，在JSP页面中可以直接使用 pageContext对象。

pageContext：作用整个页面，跳转后，则失效
request：作用当次请求，转发有效，重定向无效，刷新则无效
session：作用当次登录
application：作用整个页面

request reponse session Application config   page pageApplicaton out exception 

# 2 sql查询优化

#####     1.在表中建立索引，

​          优先考虑where group by使用的字段

#####     2.查询过程中尽量不使用select *

​              如：select * 应该改为需要查询的具体字段

#####     3.不要在where字段的两边同时使用%的模糊查询：

​            放弃索引之间全表扫描

​       如 where %zhangsan%==> where zhangsan%

#####     4.尽量不要用in或者not in(全表扫描)

​             对于连续的数值，能用between就不用in

​              对于子查询，用exists代替

#####     5.尽量不要使用or（全盘扫描）

​              SELECT * FROM t_order WHERE id = 1 OR id = 3

​              优化：可以用union代替or。如下：

​                SELECT * FROM t_order WHERE id = 1

​                UNION

​                SELECT * FROM t_order WHERE id = 3

#####    6.where条件尽量不要进行null值得判读

SELECT * FROM t_order WHERE score IS NULL

优化：

给字段添加默认值，对默认值进行判断。如：

SELECT * FROM t_order WHERE score = 0

#####   7.尽量不要在where的左侧进行表达式。函数操作

​     SELECT * FROM t_order2 WHERE score/10 = 10

​       SELECT * FROM t_order2 WHERE SUBSTR(customer,1,5) = 'zhang'

​       优化：

将表达式.函数操作移动到等号右侧。如下：

SELECT * FROM t_order2 WHERE score = 10*10

SELECT * FROM t_order2 WHERE customer LIKE 'zhang%'

#####  8.尽量不要使用where 1=1

有时候，在开发过程中，为了方便拼装查询条件，我们会加上该条件，这样，会造成进行全表扫描。如下：

​        SELECT * FROM t_order WHERE 1=1

优化：

如果用代码拼装sql，则由代码进行判断，没where加where，有where加and

如果用mybatis，请用mybatis的where语法。

# 3.java基础：

1. ##### 集合框架

   collection：

  单列：collection :List(可以重复)  Set(不可以重复)

​              List--ArryList(底层是数组)：查询快。增删慢

​              LinkedList(底层是链表)：查询慢。增删快

  双列 ：map

​       String和StringBuilder的区别：

​       1.String的内容是固定的

​       2.StringBuilder的内容是可变的



##### 2.java反射：

​        在**Java运行时环境**中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法？

　　答案是**肯定**的。

　　这种动态获取类的信息以及动态调用对象的方法的功能来自于Java语言的**反射（Reflection）机制**。

　　Java反射机制主要提供了以下功能：

　　1.在运行时判断任意**一个对象所属的类**。

　　2.在运行时**构造任意一个类的对象**。

　　3.在运行时判断任意一**个类所具有的成员变量和方法**。

　　4.在运行时调用**任意一个对象的方法**。



​      4个反射相关的类：（下述公用应该是 public关键字修饰的类 属性 方法）

######       1.Class类

[Class](https://developer.android.google.cn/reference/java/lang/Class)代表类的实体，在运行的Java应用程序中表示类和接口。在这个类中提供了很多有用的方法，这里对他们简单的分类介绍。

- **获得类相关的方法**

| 方法                       | 用途                                                   |
| -------------------------- | ------------------------------------------------------ |
| asSubclass(Class<U> clazz) | 把传递的类的对象转换成代表其子类的对象                 |
| Cast                       | 把对象转换成代表类或是接口的对象                       |
| getClassLoader()           | 获得类的加载器                                         |
| getClasses()               | 返回一个数组，数组中包含该类中所有公共类和接口类的对象 |
| getDeclaredClasses()       | 返回一个数组，数组中包含该类中所有类和接口类的对象     |
| forName(String className)  | 根据类名返回类的对象                                   |
| getName()                  | 获得类的完整路径名字                                   |
| **newInstance()**          | 创建类的实例                                           |
| getPackage()               | 获得类的包                                             |
| getSimpleName()            | 获得类的名字                                           |
| getSuperclass()            | 获得当前类继承的父类的名字                             |
| getInterfaces()            | 获得当前类实现的类或是接口                             |

- **获得类中属性相关的方法**

| 方法                          | 用途                   |
| ----------------------------- | ---------------------- |
| **getField(String name)**     | 获得某个公有的属性对象 |
| getFields()                   | 获得所有公有的属性对象 |
| getDeclaredField(String name) | 获得某个属性对象       |
| getDeclaredFields()           | 获得所有属性对象       |

- **获得类中注解相关的方法**

| 方法                                            | 用途                                   |
| ----------------------------------------------- | -------------------------------------- |
| **getAnnotation(Class<A> annotationClass)**     | 返回该类中与参数类型匹配的公有注解对象 |
| getAnnotations()                                | 返回该类所有的公有注解对象             |
| getDeclaredAnnotation(Class<A> annotationClass) | 返回该类中与参数类型匹配的所有注解对象 |
| getDeclaredAnnotations()                        | 返回该类所有的注解对象                 |

- **获得类中构造器相关的方法**

| 方法                                               | 用途                                   |
| -------------------------------------------------- | -------------------------------------- |
| getConstructor(Class...<?> parameterTypes)         | 获得该类中与参数类型匹配的公有构造方法 |
| getConstructors()                                  | 获得该类的所有公有构造方法             |
| getDeclaredConstructor(Class...<?> parameterTypes) | 获得该类中与参数类型匹配的构造方法     |
| getDeclaredConstructors()                          | 获得该类所有构造方法                   |

- **获得类中方法相关的方法**

| 方法                                                       | 用途                   |
| ---------------------------------------------------------- | ---------------------- |
| **getMethod(String name, Class...<?> parameterTypes)**     | 获得该类某个公有的方法 |
| getMethods()                                               | 获得该类所有公有的方法 |
| getDeclaredMethod(String name, Class...<?> parameterTypes) | 获得该类某个方法       |
| getDeclaredMethods()                                       | 获得该类所有方法       |

- **类中其他重要的方法**

| 方法                                                         | 用途                             |
| ------------------------------------------------------------ | -------------------------------- |
| isAnnotation()                                               | 如果是注解类型则返回true         |
| isAnnotationPresent(Class<? extends Annotation> annotationClass) | 如果是指定类型注解类型则返回true |
| isAnonymousClass()                                           | 如果是匿名类则返回true           |
| isArray()                                                    | 如果是一个数组类则返回true       |
| isEnum()                                                     | 如果是枚举类则返回true           |
| isInstance(Object obj)                                       | 如果obj是该类的实例则返回true    |
| isInterface()                                                | 如果是接口类则返回true           |
| isLocalClass()                                               | 如果是局部类则返回true           |
| isMemberClass()                                              | 如果是内部类则返回true           |

###### 2.Field类

[Field](https://developer.android.google.cn/reference/java/lang/reflect/Field)代表类的成员变量（成员变量也称为类的属性）。

| 方法                          | 用途                    |
| ----------------------------- | ----------------------- |
| equals(Object obj)            | 属性与obj相等则返回true |
| get(Object obj)               | 获得obj中对应的属性值   |
| set(Object obj, Object value) | 设置obj中对应属性值     |

###### 3.Method类

[Method](https://developer.android.google.cn/reference/java/lang/reflect/Method)代表类的方法。

| 方法                                   | 用途                                     |
| -------------------------------------- | ---------------------------------------- |
| **invoke(Object obj, Object... args)** | 传递object对象及参数调用该对象对应的方法 |

###### 4.Constructor类

[Constructor](https://developer.android.google.cn/reference/java/lang/reflect/Constructor)代表类的构造方法。

| 方法                                | 用途                       |
| ----------------------------------- | -------------------------- |
| **newInstance(Object... initargs)** | 根据传递的参数创建类的对象 |

###### 5.反射机制的优缺点

反射机制的优点：可以实现动态创建对象和编译，体现出很大的灵活性（特别是在J2EE的开发中它的灵活性就表现的十分明显）。通过反射机制我们可以获得类的各种内容，进行了反编译。对于JAVA这种先编译再运行的语言来说，反射机制可以使代码更加灵活，更加容易实现面向对象。

　　比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。 

反射机制的缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它 满足我们的要求。这类操作总是慢于只直接执行相同的操作。

##### 3.(动态代理)Proxy（都是通过修改字节码文件）

  ![img](https://img-blog.csdn.net/2018052117143651?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTcxNTA2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

    这张图便是动态代理大概的实现流程,我们看到.只有javaProxy是直接修改字节码的,其他的都是基于ASM来操作字节码ASM我也不太懂,然后那个javassist也是用来操作ASM的,是岛国一位工程师写的,据说dubbo就是用的这项技术.

我们看到无论是何种方式它都是基于对class字节码的修改来进行代理的

好的这只是一个大概的了解那么我们来写代码感受感受:

整体需求就是一个普通的Service接口,

让后一个普通的实现类,ServiceImpl 

最后我们来个测试的小方法:来看看动态代理的实现:

```java
`public class ProjexTest {
    public static void main(String[] args) {
        final  serviceImpl impl =new serviceImpl();
        UserServce  servce = (UserServce)Proxy.newProxyInstance(ProjexTest.class.getClassLoader(), new Class[]{UserServce.class}, new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println("代理执行前");
                try {
                    return method.invoke(impl, args);
                } finally {
                    System.out.println("代理执行后");
                }
            }
        });
        servce.get();
    }`
```


我们还是很奇怪上面到底是什么东东?用我表达不好语言解释一下:

首先,我们new 了一个**newProxyInstance()然后我们在InvocationHandler()里面的invoke方法来实现它的动态代理.**



还是贴图方便一点这样我们便实现了一个简单的代理类



这里的我们get()方法就相当于客户端,掉的是userservice接口的方法,委托类就是serviceimpl 代理类就是我们传的userservice.class,这样通过接口屏蔽的底层的实现细节,这样透明化喽.



对啊是如何做到代理目标对象的呢?这个好说我们通过代理类来分析一下:

```java
@Test
public void buildProcyClass() throws IOException {
    byte[] bytes = ProxyGenerator.generateProxyClass("UserService$proxy", new Class[]{
            UserServce.class
    });
    String filename = String.format("%s/target/UserService$proxy.class",                     System.getProperty("user.dir"));
    File file = new File(filename);
    FileOutputStream outputStream = new FileOutputStream(file);
    outputStream.write(bytes);
    outputStream.flush();
    outputStream.close();
}
```


这样我就把它代理的类输出出来了:



```java
public final class UserService$proxy extends Proxy implements UserServce {
    private static Method m1;
    private static Method m2;
    private static Method m3;
    private static Method m0;
public UserService$proxy(InvocationHandler var1) throws  {
    super(var1);
}

public final boolean equals(Object var1) throws  {
    try {
        return ((Boolean)super.h.invoke(this, m1, new Object[]{var1})).booleanValue();
    } catch (RuntimeException | Error var3) {
        throw var3;
    } catch (Throwable var4) {
        throw new UndeclaredThrowableException(var4);
    }
}

public final String toString() throws  {
    try {
        return (String)super.h.invoke(this, m2, (Object[])null);
    } catch (RuntimeException | Error var2) {
        throw var2;
    } catch (Throwable var3) {
        throw new UndeclaredThrowableException(var3);
    }
}

public final String get() throws  {
    try {
        return (String)super.h.invoke(this, m3, (Object[])null);
    } catch (RuntimeException | Error var2) {
        throw var2;
    } catch (Throwable var3) {
        throw new UndeclaredThrowableException(var3);
    }
}

public final int hashCode() throws  {
    try {
        return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();
    } catch (RuntimeException | Error var2) {
        throw var2;
    } catch (Throwable var3) {
        throw new UndeclaredThrowableException(var3);
    }
}

static {
    try {
        m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));
        m2 = Class.forName("java.lang.Object").getMethod("toString");
        m3 = Class.forName("com.yqun.springboot.service.UserServce").getMethod("get");
        m0 = Class.forName("java.lang.Object").getMethod("hashCode");
    } catch (NoSuchMethodException var2) {
        throw new NoSuchMethodError(var2.getMessage());
    } catch (ClassNotFoundException var3) {
        throw new NoClassDefFoundError(var3.getMessage());
    }
}
```
这个就是输出来的类,我们可以看到代理过来的类:

return ((Boolean)super.h.invoke(this, m1, new Object[]{var1})).booleanValue(); 里面的参数就对应着:

 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { 上问中这个invoke里面要的参数,

其实这样我们可以清楚的看到,代理类回事怎么一回事

我们看看他是怎么生成的:追 类 可以通过了吗看到它就是生成一个动态代理对对象



```java
public static Object newProxyInstance(ClassLoader loader,
                                      Class<?>[] interfaces,
                         InvocationHandler h)
```


/*获取查询遍历已经构建好的class类也就是我们接口的代理类

```java
    * Look up or generate the designated proxy class.
   */
   Class<?> cl = getProxyClass0(loader, intfs);
   // If the proxy class defined by the given loader implementing //点进去首先会通过从load缓存里面取
   // the given interfaces exists, this will simply return the cached copy;//如果有对它从字节码进行构建
   // otherwise, it will create the proxy class via the ProxyClassFactory//没有的话去创建一个新的
   return proxyClassCache.get(loader, interfaces);
   我们看到如果它没有的话回去ProxyClassFactory类里面去实现那么我们就看看里面的方法,

 -->ProxyClassFactory.apply 就是装配自动代理的过程 动态代理所用的接口
        public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {
			//存储所有动态代理所对应的接口
            Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);
            for (Class<?> intf : interfaces) {
                /*验证接口 也就是说ClassLoader 对应的接口是否已经存在是否是同一个
                 * Verify that the class loader resolves the name of this
                 * interface to the same Class object.
```

也就是说对代理的类是不service的实现类

当然里面还有许多乱七八糟的方法,但是我只看懂了这个.这里他会对字节码重组也就是修改class文件,相当于吧代码编译成字节码

在往深就是类加载器的方法了,这个便是对字节码的重新装载 也就是ClassLoad里面的



```java
@Deprecated
protected final Class<?> defineClass(byte[] b, int off, int len)
    throws ClassFormatError
{
    return defineClass(null, b, off, len, null);
}
```

的方法

总结两张图结尾:

![img](https://img-blog.csdn.net/2018052118002052?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTcxNTA2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



最后一张图特别重要,也就是写了这么长时间的总计吧算是...



JDK代理要求被代理的类必须实现接口，有很强的局限性。而CGLIB动态代理则没有此类强制性要求。简单的说，CGLIB会让生成的代理类继承被代理类，并在代理类中对代理方法进行强化处理(前置处理、后置处理等)。但是如果被代理类被final修饰，那么它不可被继承，即不可被代理；同样，如果被代理类中存在final修饰的方法，那么该方法也不可被代理。

​    jdk动态代理直接操作java原始API比较快（继承 proxy 实现 代理类父类接口）

   cglib通过ASM来操作字节码文件比较慢（继承代理类 实现Factory接口）

##### 4.java虚拟机（jvm）

​     JVM一直是java知识里面进阶阶段的重要部分，如果希望在java领域研究的更深入，则JVM则是如论如何也避开不了的话题，本系列试图通过简洁易读的方式，讲解JVM必要的知识点。

运行流程

 我们都知道java一直宣传的口号是：一次编译，到处运行。那么它如何实现的呢？我们看下图：

[![image](https://images2017.cnblogs.com/blog/352511/201708/352511-20170810232430449-973255879.png)](http://images2017.cnblogs.com/blog/352511/201708/352511-20170810232429980-107444580.png)

 java程序经过一次编译之后，将java代码编译为字节码也就是class文件，然后在不同的操作系统上依靠不同的java虚拟机进行解释，最后再转换为不同平台的机器码，最终得到执行。这样我们是不是可以推演，如果要在mac系统上运行，是不是只需要安装mac java虚拟机就行了。那么了解了这个基本原理后，我们尝试去做更深的研究，一个普通的java程序它的执行流程到底是怎样的呢？例如我们写了一段这样的代码：

public class HelloWorld { public static void main(String[] args) { System.out.print("Hello world"); } }

这段程序从编译到运行，最终打印出“Hello world”中间经过了哪些步骤呢？我们直接上图：

[![image](https://images2017.cnblogs.com/blog/352511/201708/352511-20170810232431824-998419876.png)](http://images2017.cnblogs.com/blog/352511/201708/352511-20170810232431105-2080375000.png)

 java代码通过编译之后生成字节码文件（class文件），通过：java HelloWorld执行，此时java根据系统版本找到jvm.cfg，各位可以搜索一下自己电脑上的jvm.cfg文件在哪，它会根据你的系统版本放在不同的位置，比如我的这个文件就在：C:\Program Files\Java\jdk1.8.0_101\jre\lib\amd64\jvm.cfg，打开看一下：

[![S{6G7J8WOT3$)72FL1DW5U7](https://images2017.cnblogs.com/blog/352511/201708/352511-20170810232432745-1430939026.png)](http://images2017.cnblogs.com/blog/352511/201708/352511-20170810232432183-490667295.png)

 这是我电脑上的文件，其中-server KNOWN就表示名称为server的jvm可用。如果这时你搜索一下你电脑上jvm.dll，你就会发现它一定在你的某个server目录下，比如我的：C:\Program Files\Java\jdk1.8.0_101\jre\bin\server\jvm.dll。简而言之就是通过jvm.cfg文件找到对应的jvm.dll，jvm.dll则是java虚拟机的主要实现。接下来会初始化JVM,并且获取JNI接口，什么是JNI接口，就是java本地接口，你想啊java被编译成了class文件，JVM怎么从硬盘上找到这个文件并装载到JVM里呢，就是通过JNI接口（它还常用于java与操作系统、硬件交互），找到class文件后并装载进JVM，然后找到main方法，最后执行。

JVM基本结构

 可能通过上面的描述，大家对JVM运行流程有了一个粗略的认识，那么JVM内部到底是怎么执行一个class文件的呢，也就是上图中最后一步第6步的内部细节是怎样的呢？要了解这个问题，我们首先得看一下JVM的内部结构：

[![image](https://images2017.cnblogs.com/blog/352511/201708/352511-20170810232433792-373676900.png)](http://images2017.cnblogs.com/blog/352511/201708/352511-20170810232433277-922435213.png)

 从这个结构不难看出，class文件被jvm装载以后，经过jvm的内存空间调配，最终是由执行引擎完成class文件的执行。当然这个过程还有其他角色模块的协助，这些模块协同配合才能让一个java程序成功的运行，下面就详细介绍这些模板，它们也是后面学习jvm最重要的部分。

内存空间：

JVM内存空间包含：方法区、java堆、java栈、本地方法栈。

方法区是各个线程共享的区域，存放类信息、常量、静态变量。

java堆也是线程共享的区域，我们的类的实例就放在这个区域，可以想象你的一个系统会产生很多实例，因此java堆的空间也是最大的。如果java堆空间不足了，程序会抛出OutOfMemoryError异常。

java栈是每个线程私有的区域，它的生命周期与线程相同，一个线程对应一个java栈，每执行一个方法就会往栈中压入一个元素，这个元素叫“栈帧”，而栈帧中包括了方法中的局部变量、用于存放中间状态值的操作栈，这里面有很多细节，我们以后再讲。如果java栈空间不足了，程序会抛出StackOverflowError异常，想一想什么情况下会容易产生这个错误，对，递归，递归如果深度很深，就会执行大量的方法，方法越多java栈的占用空间越大。

每个帧代表一个方法，Java方法有两种返回方式，return和抛出异常，两种方式都会导致该方法对应的帧出栈和释放内存。

 ③ 栈运行原理

   栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中，A方法又调用了B方法，于是产生栈帧F2也被压入栈，B方法又调用了C方法，于是产生栈帧F3也被压入栈…… 依次执行完毕后，先弹出后进......F3栈帧，再弹出F2栈帧，再弹出F1栈帧。

   遵循“先进后出”/“后进先出”原则。

  帧的组成：**局部变量区**（包括方法参数和局部变量，对于instance方法，还要首先保存this类型，其中方法参数按照声明顺序严格放置，局部变量可以任意放置），**操作数栈**，**帧数据区**（用来帮助支持常量池的解析，正常方法返回和异常处理）。

本地方法栈角色和java栈类似，只不过它是用来表示执行本地方法的，**本地方法栈存放的方法调用本地方法接口，最终调用本地方法库，实现与操作系统、硬件交互的目的**。

PC寄存器，说到这里我们的类已经加载了，实例对象、方法、静态变量都去了自己改去的地方，那么问题来了，程序该怎么执行，哪个方法先执行，哪个方法后执行，这些指令执行的顺序就是PC寄存器在管，它的作用就是控制程序指令的执行顺序。

**执行引擎当然就是根据PC寄存器调配的指令顺序，依次执行程序指令。**

****

**静态变量+常量+类信息+运行时常量池**存在方法区中，实例变量存在堆内存中。

 基本类型的变量和对象的引用变量都是在函数的栈内存中分配。

1. **Java 内存区域与内存溢出异常**
1.1 运行时数据区域
根据《Java 虚拟机规范(Java SE 7 版)》规定，Java 虚拟机所管理的内存如下图所示。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGQzYjE1YjNkODgyNmZhZWFlMjA2Mzk3NmZiOTkyMTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

 

**1.1.1 程序计数器**

内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，***分支、循环、跳转、异常处理、线程恢复****等基础功能都需要依赖计数器完成

如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器的值则为 (Undefined)。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。

**1.1.2 Java 虚拟机栈**

**线程私有，生命周期**和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。**每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程**。

局部变量表：存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)

StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。
OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。

**1.1.3 本地方法栈**

区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，**而本地方法栈则为虚拟机使用到的 Native 方法服务**。也会有 StackOverflowError 和 OutOfMemoryError 异常。

**1.1.4 Java 堆**

对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。**线程共享**，主要是存放**对象实例和数组**。内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。可以位于物理上不连续的空间，但是逻辑上要连续。

OutOfMemoryError：如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。

**1.1.5 方法区**

**属于共享内存区域**，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

现在用一张图来介绍每个区域存储的内容。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGE3N2Q5MDE0Njc4NmMwY2IzZTE3MGI5YzkzNzZhZTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

 

**1.1.6 运行时常量池**

**属于方法区一部分**，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String 的 intern() )都可以将常量放入池中。内存有限，无法申请时抛出 OutOfMemoryError。

**1.1.7 直接内存**

非虚拟机运行时数据区的部分

在 JDK 1.4 中新加入 NIO (New Input/Output) 类，引入了一种基于通道(Channel)和缓存(Buffer)的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。可以避免在 Java 堆和 Native 堆中来回的数据耗时操作。
OutOfMemoryError：会受到本机内存限制，如果内存区域总和大于物理内存限制从而导致动态扩展时出现该异常。

**1.2 HotSpot 虚拟机对象探秘**
主要介绍数据是**如何创建**、**如何布局**以及**如何访问**的。

**1.2.1 对象的创建**

创建过程比较复杂，建议看书了解，这里提供个人的总结。

遇到 new 指令时，首先检查这个指令的参数是否能在**常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，执行相应的类加载**。(第一步从常量池中获取信息)

类加载检查通过之后，为新对象分配内存(内存大小在类加载完成后便可确认)。在堆的空闲内存中划分一块区域(‘指针碰撞-内存规整’或‘空闲列表-内存交错’的分配方式)。（第二步 类加载检查-->分配内存空间）

前面讲的每个线程在堆中都会有私有的分配缓冲区(TLAB)，这样可以很大程度避免在并发情况下频繁创建对象造成的线程不安全。

内存空间分配完成后会初始化为 0(不包括对象头)，**接下来就是填充对象头**，把对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息存入对象头。（第三步 先初始化为0-->填充对头）

执行 new 指令后执行 init 方法后才算一份真正可用的对象创建完成。

（**new指令---》检查方法区常量池中是否有信息（无则进入类加载过程）---》类加载检查---》为对象分配内存----》初始化为0---》填充对象头---》init方法执行---》创建完成**）

**1.2.2 对象的内存布局**

在 HotSpot 虚拟机中，分为 3 块区域：**对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)**

**对象头**(Header)：包含两部分，**第一部分用于存储对象自身的运行时数据**，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。**第二部分**是**类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例**。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。

实例数据(Instance Data)：**程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的**)。

对齐填充(Padding)：不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。

**1第一部分用于存储对象自身的运行时数据***2第二部分**是**类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例**



| 对象内存分布 |                             内容                             |
| ------------ | :----------------------------------------------------------: |
| 方法头       | **1第一部分用于存储对象自身的运行时数据***2第二部分**是**类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例** |
| 实例数据     | **程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的**) |
| 填充内容     |   不是必然需要，主要是占位，保证对象大小是某个字节的整数倍   |

1.2.3 对象的访问定位

**使用对象时，通过栈上的 reference 数据来操作堆上的具体对象**。

通过句柄访问

Java 堆中会分配一块内存作为句柄池。reference 存储的是句柄地址。详情见图。



![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZWJmMDBlZDI2YzM1YWVmZDkzZDVhM2EzNmIzYjE2MTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

使用直接指针访问

reference 中直接存储对象地址

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGU2OTI0YjZlOWQ1NzYxMDViYTI0NzAwZjFmMzU3ZjQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

 

比较：使用句柄的最大好处是 reference 中存储的是稳定的句柄地址，在对象移动(GC)时只改变实例数据指针地址，reference 自身不需要修改。直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销。如果是对象频繁 GC 那么句柄方法好，如果是对象频繁访问则直接指针访问好。

1.3 实战
// 待填

2. 垃圾回收器与内存分配策略
2.1 概述
**程序计数器、虚拟机栈、本地方法栈 3 个区域随线程生灭(**因为是线程私有)，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。而 **Java 堆和方法区则不一样**，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处**于运行期才知道那些对象会创建**，这部分内存的分配和回收都是动态的，**垃圾回收期所关注的就是这部分内存**。

2.2 对象已死吗？
在进行内存回收之前要做的事情就是判断那些对象是‘死’的，哪些是‘活’的。

2.2.1 引用计数法

给对象添加一个引用计数器。但是难以解决循环引用问题。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNGMyODlhMjI0Y2I0OTQ0ZTQ5OWZiNWJmZDMzZTU5MmY_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

从图中可以看出，如果不下小心直接把 Obj1-reference 和 Obj2-reference 置 null。则在 Java 堆当中的两块内存依然保持着互相引用无法回收。

2.2.2 可达性分析法

通过一系列的 ‘GC Roots’ 的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连的时候说明对象不可用。



 ![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNThiZmFjMTVjYTZkMzA3NmRlZjUxNzRlZDVjYTVhOTk_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

可作为 GC Roots 的对象：

虚拟机栈(栈帧中的本地变量表)中引用的对象
方法区中类静态属性引用的对象
方法区中常量引用的对象
本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象
2.2.3 再谈引用

前面的两种方式判断存活时都与‘引用’有关。但是 JDK 1.2 之后，引用概念进行了扩充，下面具体介绍。

下面四种引用强度一次逐渐减弱

强引用

类似于 Object obj = new Object(); 创建的，只要强引用在就不回收。

软引用

SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。

弱引用

WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。

虚引用

PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

2.2.4 生存还是死亡

即使在可达性分析算法中不可达的对象，也并非是“facebook”的，这时候它们暂时出于“缓刑”阶段，一个对象的真正死亡至少要经历两次标记过程：如果对象在进行中可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。

如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象竟会放置在一个叫做 F-Queue 的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里所谓的“执行”是指虚拟机会出发这个方法，并不承诺或等待他运行结束。finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己 —— 只要重新与引用链上的任何一个对象简历关联即可。（不可达--第一次被标记并筛选（是否有必要执行）finalize()方法---》进入 F-Queue 的队列---对队列中的对象进行标记除非他们重新与引用链相连）

finalize() 方法只会被系统自动调用一次。

2.2.5 回收方法区

在堆中，尤其是在新生代中，一次垃圾回收一般可以回收 70% ~ 95% 的空间，而永久代的垃圾收集效率远低于此。

**永久代垃圾回收主要两部分内容：废弃的常量和无用的类**。

判断废弃常量：一般是判断没有该常量的引用。

判断无用的类：要以下三个条件都满足

**该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例**
**加载该类的 ClassLoader 已经被回收**
**该类对应的 java.lang.Class 对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法**
2.3 垃圾回收算法
仅提供思路

2.3.1 标记 —— 清除算法

直接标记清除就可。

两个不足：

效率不高
空间会产生大量碎片
2.3.2 复制算法

把空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。

解决前一种方法的不足，但是会造成空间利用率低下。因为大多数新生代对象都不会熬过第一次 GC。所以没必要 1 : 1 划分空间。可以分一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 上，最后清理 Eden 和 Survivor 空间。大小比例一般是 8 : 1 : 1，每次浪费 10% 的 Survivor 空间。但是这里有一个问题就是如果存活的大于 10% 怎么办？这里采用一种分配担保策略：多出来的对象直接进入老年代。

2.3.3 标记-整理算法

不同于针对新生代的复制算法，针对老年代的特点，创建该算法。主要是把存活对象移到内存的一端。

2.3.4 分代回收

根据存活对象划分几块内存区，一般是分为新生代和老年代。然后根据各个年代的特点制定相应的回收算法。

新生代

每次垃圾回收都有大量对象死去，只有少量存活，选用复制算法比较合理。

老年代

老年代中对象存活率较高、没有额外的空间分配对它进行担保。所以必须使用 标记 —— 清除 或者 标记 —— 整理 算法回收。

2.4 HotSpot 的算法实现
// 待填

2.5 垃圾回收器
收集算法是内存回收的理论，而垃圾回收器是内存回收的实践。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMTVmYjc1NDc2MmZmNWRmM2Y3ZjYzZTVjMjZkNGQzYWU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)



 

说明：如果两个收集器之间存在连线说明他们之间可以搭配使用。

2.5.1 Serial (顺序排列)收集器

这是一个单线程收集器。意味着它只会使用一个 CPU 或一条收集线程去完成收集工作，并且在进行垃圾回收时必须暂停其它所有的工作线程直到收集结束。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYjE4NDk0YjFlNTQ4NTFiYmJkMmVlNTI3NjBjYzM3NTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

 

2.5.2 ParNew 收集器

可以认为是 Serial 收集器的多线程版本。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMTU0NjVmYjJlMTdjYjVkNjY1YzI1YmI5OGFjZmVhOTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

 

并行：Parallel

指多条垃圾收集线程并行工作，此时用户线程处于等待状态

并发：Concurrent

指用户线程和垃圾回收线程同时执行(不一定是并行，有可能是交叉执行)，用户进程在运行，而垃圾回收线程在另一个 CPU 上运行。

2.5.3 Parallel Scavenge 收集器

这是一个新生代收集器，也是使用复制算法实现，同时也是并行的多线程收集器。

CMS 等收集器的关注点是尽可能地**缩短垃圾收集时用户线程所停顿的时间**，而 Parallel Scavenge 收集器的目的是达到一个可控制的吞吐量(Throughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间))。

作为一个吞吐量优先的收集器，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整停顿时间。这就是 GC 的自适应调整策略(GC Ergonomics)。

2.5.4 Serial Old 收集器

收集器的老年代版本，单线程，使用 标记 —— 整理。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYjE4NDk0YjFlNTQ4NTFiYmJkMmVlNTI3NjBjYzM3NTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

 

2.5.5 Parallel Old 收集器

Parallel Old 是 Parallel Scavenge 收集器的老年代版本。多线程，使用 标记 —— 整理

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjU2NDEzNjZiNDNkOTcxMzEwYTBhN2NlZGU0ZTQwNmE_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

 

2.5.6 CMS 收集器

CMS (Concurrent Mark Sweep) 收集器是一种以**获取最短回收停顿时间为目标的收集器**。基于 标记 —— 清除 算法实现。

运作步骤:

初始标记(CMS initial mark)：标记 GC Roots 能直接关联到的对象
并发标记(CMS concurrent mark)：进行 GC Roots Tracing
重新标记(CMS remark)：修正并发标记期间的变动部分
并发清除(CMS concurrent sweep)

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNmY0ZDY4MzY0NGExNTQ1MzdiM2UyM2Q2MGQ0OWMwNzQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)


缺点：对 CPU 资源敏感、无法收集浮动垃圾、标记 —— 清除 算法带来的空间碎片

2.5.7 G1 收集器

**面向服务端的垃圾回收器**。

优点：**并行与并发、分代收集、空间整合、可预测停顿**。

运作步骤:

初始标记(Initial Marking)
并发标记(Concurrent Marking)
最终标记(Final Marking)
筛选回收(Live Data Counting and Evacuation)

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNDBhNTc1OTMxYjI1NGE4ZjQwYmI1NDNjMjRlOGZhZGY_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

2.6 内存分配与回收策略
2.6.1 对象优先在 Eden 分配

对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲区，将线程优先在 (TLAB) 上分配。少数情况会直接分配在老年代中。

一般来说 Java 堆的内存模型如下图所示：

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOTcxMDE4MDMxNWQzNTc1NmI2OGU5YzVkYWY0NGQ2ZTU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)




新生代 GC (Minor GC)

发生在新生代的垃圾回收动作，频繁，速度快。

老年代 GC (Major GC / Full GC)

发生在老年代的垃圾回收动作，出现了 Major GC 经常会伴随至少一次 Minor GC(非绝对)。Major GC 的速度一般会比 Minor GC 慢十倍以上。

2.6.2 大对象直接进入老年代

2.6.3 长期存活的对象将进入老年代

2.6.4 动态对象年龄判定

2.6.5 空间分配担保

3. Java 内存模型与线程

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjBhOTk2ODc0NmFmYTJhZmRlNGIzNzE2YmFiZjU1Y2U_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)


3.1 Java 内存模型
屏蔽掉各种硬件和操作系统的内存访问差异。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOGY5ODMzMGRjOGFmNGNlOGNmNTM5N2EwMTMzMDhlYzI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

 

**3.1.1 主内存和工作内存之间的交互**

操作	作用对象	解释
lock	主内存	把一个变量标识为一条线程独占的状态
unlock	主内存	把一个处于锁定状态的变量释放出来，释放后才可被其他线程锁定
read	主内存	把一个变量的值从主内存传输到线程工作内存中，以便 load 操作使用
load	工作内存	把 read 操作从主内存中得到的变量值放入工作内存中
use	工作内存	把工作内存中一个变量的值传递给执行引擎，
每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作
assign	工作内存	把一个从执行引擎接收到的值赋接收到的值赋给工作内存的变量，
每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
store	工作内存	把工作内存中的一个变量的值传送到主内存中，以便 write 操作
write	工作内存	把 store 操作从工作内存中得到的变量的值放入主内存的变量中
3.1.2 对于 volatile 型变量的特殊规则

关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制。

一个变量被定义为 volatile 的特性：

保证此变量对所有线程的可见性。但是操作并非原子操作，并发情况下不安全。
如果不符合 运算结果并不依赖变量当前值，或者能够确保只有单一的线程修改变量的值 和 变量不需要与其他的状态变量共同参与不变约束 就要通过加锁(使用 synchronize 或 java.util.concurrent 中的原子类)来保证原子性。

禁止指令重排序优化。
通过插入内存屏障保证一致性。

3.1.3 对于 long 和 double 型变量的特殊规则

Java 要求对于主内存和工作内存之间的八个操作都是原子性的，但是对于 64 位的数据类型，有一条宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。这就是 long 和 double 的非原子性协定。

3.1.4 原子性、可见性与有序性

回顾下并发下应该注意操作的那些特性是什么，同时加深理解。

原子性(Atomicity)
由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write。大致可以认为基本数据类型的操作是原子性的。同时 lock 和 unlock 可以保证更大范围操作的原子性。而 synchronize 同步块操作的原子性是用更高层次的字节码指令 monitorenter 和 monitorexit 来隐式操作的。

可见性(Visibility)
是指当一个线程修改了共享变量的值，其他线程也能够立即得知这个通知。主要操作细节就是修改值后将值同步至主内存(volatile 值使用前都会从主内存刷新)，除了 volatile 还有 synchronize 和 final 可以保证可见性。同步块的可见性是由“对一个变量执行 unlock 操作之前，必须先把此变量同步会主内存中( store、write 操作)”这条规则获得。而 final 可见性是指：被 final 修饰的字段在构造器中一旦完成，并且构造器没有把 “this” 的引用传递出去( this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那在其他线程中就能看见 final 字段的值。

有序性(Ordering)
如果在被线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句指“线程内表现为串行的语义”，后半句是指“指令重排”现象和“工作内存与主内存同步延迟”现象。Java 语言通过 volatile 和 synchronize 两个关键字来保证线程之间操作的有序性。volatile 自身就禁止指令重排，而 synchronize 则是由“一个变量在同一时刻指允许一条线程对其进行 lock 操作”这条规则获得，这条规则决定了持有同一个锁的两个同步块只能串行的进入。

3.1.5 先行发生原则

也就是 happens-before 原则。这个原则是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是 Java 内存模型中定义的两项操作之间的偏序关系。

天然的先行发生关系

| 规则              | 解释                                                         |
| ----------------- | ------------------------------------------------------------ |
| 程序次序规则      | 在一个线程内，代码按照书写的控制流顺序执行                   |
| 管程锁定规则      | 一个 unlock 操作先行发生于后面对同一个锁的 lock 操           |
| volatile 变量规则 | volatile 变量的写操作先行发生于后面对这个变量的读操作        |
| 线程启动规则      | Thread 对象的 start() 方法先行发生于此线程的每一个动作       |
| 线程终止规则      | 线程中所有的操作都先行发生于对此线程的终止检测(通过 Thread.join() 方法结束、 Thread.isAlive() 的返回值检测) |
| 线程中断规则      | 对线程 interrupt() 方法调用优先发生于被中断线程的代码检测到中断事件的发生<br/>(通过 Thread.interrupted() 方法检测) |
| 对象终结规则      | 一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始 |
| 传递性            | 如果操作 A 先于 操作 B 发生，操作 B 先于 操作 C 发生，那么操作 A 先于 操作 C3.2 Java 与线程 |


3.2.1 线程的实现

使用内核线程实现

直接由操作系统内核支持的线程，这种线程由内核完成切换。程序一般不会直接去使用内核线程，**而是去使用内核线程的一种高级接口 —— 轻量级进程(LWP)**，轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都有一个内核级线程支持。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNGMwYTk1OTQ1ZTdjN2E1MmVmNmNjYmE0YWJiNzNkNDM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

 

使用用户线程实现

广义上来说，只要不是内核线程就可以认为是用户线程，因此可以认为轻量级进程也属于用户线程。狭义上说是完全建立在用户空间的线程库上的并且内核系统不可感知的。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZDE1YjY5NDgyNTIyMTAxMDRkOWNjY2YxODJkYjU4MjU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

 

使用用户线程夹加轻量级进程混合实现

直接看图

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZjE2MmMwYmUwMGU0NzI5NTIyZmNlNDhkMjA5ODk5MTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

 

Java 线程实现

平台不同实现方式不同，可以认为是一条 **Java 线程映射到一条轻量级进程。**

3.2.2 Java 线程调度

协同式线程调度

线程执行时间由线程自身控制，实现简单，切换线程自己可知，所以基本没有线程同步问题。坏处是执行时间不可控，容易阻塞。

抢占式线程调度

每个线程由系统来分配执行时间。

**3.2.3 状态转换**

五种状态：

新建(new)
创建后尚未启动的线程。

运行(Runable)
Runable 包括了操作系统线程状态中的 Running 和 Ready，也就是出于此状态的线程有可能正在执行，也有可能正在等待 CPU 为他分配时间。

无限期等待(Waiting)
出于这种状态的线程不会被 CPU 分配时间，它们要等其他线程显示的唤醒。

以下方法会然线程进入无限期等待状态：
1.没有设置 Timeout 参数的 Object.wait() 方法。
2.没有设置 Timeout 参数的 Thread.join() 方法。
3.LookSupport.park() 方法。

限期等待(Timed Waiting)
处于这种状态的线程也不会分配时间，不过无需等待配其他线程显示地唤醒，在一定时间后他们会由系统自动唤醒。

以下方法会让线程进入限期等待状态：
1.Thread.sleep() 方法。
2.设置了 Timeout 参数的 Object.wait() 方法。
3.设置了 Timeout 参数的 Thread.join() 方法。
4.LockSupport.parkNanos() 方法。
5.LockSupport.parkUntil() 方法。

阻塞(Blocked)
线程被阻塞了，“阻塞状态”和“等待状态”的区别是：“阻塞状态”在等待着获取一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。

结束(Terminated)
已终止线程的线程状态。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNmFmOGVlNThhNTU0YWYzMmFjOTI0NGQ2NDY5MjFiYzc_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

 

4. 线程安全与锁优化
// 待填

5. 类文件结构
// 待填

有点懒了。。。先贴几个网址吧。

1. Official：The class File Format
2.亦山: 《Java虚拟机原理图解》 1.1、class文件基本组织结构

6. 虚拟机类加载机制
虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、装换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。

在 Java 语言中，**类型的加载、连接和初始化过程都是在程序运行期间完成的**。

6.1 类加载时机
类的生命周期( 7 个阶段)



 ![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjdhYzg3ZjQzOTJmMGFiOTllNGM2NWMyM2NjNzE5NDU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。解析阶段可以在初始化之后再开始(运行时绑定或动态绑定或晚期绑定)。

以下五种情况必须对类进行初始化(而加载、验证、准备自然需要在此之前完成)：

遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时没初始化触发初始化。使用场景：使用 new 关键字实例化对象、读取一个类的静态字段(被 final 修饰、已在编译期把结果放入常量池的静态字段除外)、调用一个类的静态方法。
使用 java.lang.reflect 包的方法对类进行反射调用的时候。
当初始化一个类的时候，如果发现其父类还没有进行初始化，则需先触发其父类的初始化。
当虚拟机启动时，用户需指定一个要加载的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类。
当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需先触发其初始化。
前面的五种方式是对一个类的主动引用，除此之外，所有引用类的方法都不会触发初始化，佳作被动引用。举几个例子~



```java
public class SuperClass {
    static {
        System.out.println("SuperClass init!");
    }
    public static int value = 1127;
}

public class SubClass extends SuperClass {
    static {
        System.out.println("SubClass init!");
    }
}

public class ConstClass {
    static {
        System.out.println("ConstClass init!");
    }
    public static final String HELLOWORLD = "hello world!"
}

public class NotInitialization {
    public static void main(String[] args) {
        System.out.println(SubClass.value);
        /**

   *  output : SuperClass init!

         * 通过子类引用父类的静态对象不会导致子类的初始化
           接定义这个字段的类才会被初始化
                    */    
SuperClass[] sca = new SuperClass[10];
    /**
     *  output : 
     * 
     * 通过数组定义来引用类不会触发此类的初始化
     * 虚拟机在运行时动态创建了一个数组类
     */
 
    System.out.println(ConstClass.HELLOWORLD);
    /**
     *  output : 
     * 
     * 常量在编译阶段会存入调用类的常量池当中，本质上并没有直接引用到定义类常量的类，
     * 因此不会触发定义常量的类的初始化。
     * “hello world” 在编译期常量传播优化时已经存储到 NotInitialization 常量池中了。
     */
}
```

**6.2 类的加载过程**

**6.2.1 加载**

**通过一个类的全限定名来获取定义此类的二进制流(ZIP 包、网络、运算生成、JSP 生成、数据库读取)**。
将这个字节流所代表的静态存**储结构转化为方法区的运行时数据结构**。
在内存中生成一个代表这个**类的 java.lang.Class 对象**，作为**方法区**这个类的各种数据的访问入口。
数组类的特殊性：数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建的，数组创建过程如下：

如果数组的组件类型是引用类型，那就递归采用类加载加载。
如果数组的组件类型不是引用类型，Java 虚拟机会把数组标记为引导类加载器关联。
数组类的可见性与他的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为 public。
内存中**实例的 java.lang.Class 对象存在方法区中**。作为程序访问方法区中这些类型数据的外部接口。
加载阶段与连接阶段的部分内容是交叉进行的，但是开始时间保持先后顺序。

**6.2.2 验证**

是连接的第一步，确保 Class 文件的字节流中包含的信息符合当前虚拟机要求。

文件格式验证

是否以魔数 0xCAFEBABE 开头
主、次版本号是否在当前虚拟机处理范围之内
常量池的常量是否有不被支持常量的类型（检查常量 tag 标志）
指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据
Class 文件中各个部分集文件本身是否有被删除的附加的其他信息
……
只有通过这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面 3 个验证阶段全部是基于方法区的存储结构进行的，不再直接操作字节流。

元数据验证

这个类是否有父类（除 java.lang.Object 之外）
这个类的父类是否继承了不允许被继承的类（final 修饰的类）
如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法
类中的字段、方法是否与父类产生矛盾（覆盖父类 final 字段、出现不符合规范的重载）
这一阶段主要是对类的元数据信息进行语义校验，保证不存在不符合 Java 语言规范的元数据信息。

字节码验证

保证任意时刻操作数栈的数据类型与指令代码序列都鞥配合工作（不会出现按照 long 类型读一个 int 型数据）
保证跳转指令不会跳转到方法体以外的字节码指令上
保证方法体中的类型转换是有效的（子类对象赋值给父类数据类型是安全的，反过来不合法的）
……
这是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段对类的方法体进行校验分析，保证校验类的方法在运行时不会做出危害虚拟机安全的事件。

符号引用验证

符号引用中通过字符创描述的全限定名是否能找到对应的类
在指定类中是否存在符方法的字段描述符以及简单名称所描述的方法和字段
符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问
……
最后一个阶段的校验发生在迅疾将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，还有以上提及的内容。
符号引用的目的是确保解析动作能正常执行，如果无法通过符号引用验证将抛出一个 java.lang.IncompatibleClass.ChangeError 异常的子类。如 java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError 等。

**6.2.3 准备**

这个阶段**正式为类分配内存并设置类变量初始值**，内存在方法区中分配(**含 static 修饰的变量不含实例变量**)。

public static int value = 1127;
这句代码在初始值设置之后为 0，因为这时候尚未开始执行任何 Java 方法。而把 value 赋值为 1127 的 putstatic 指令是程序被编译后，存放于 clinit() 方法中，所以初始化阶段才会对 value 进行赋值。

基本数据类型的零值

数据类型	零值	数据类型	零值
int	0	boolean	false
long	0L	float	0.0f
short	(short) 0	double	0.0d
char	'\u0000'	reference	null
byte	(byte) 0	 
特殊情况：如果类字段的字段属性表中存在 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 1127。

**6.2.4 解析**

**这个阶段是虚拟机将常量池内的符号引用替换为直接引用的过程**。

符号引用
符号引用以一组符号来描述所引用的目标，符号可以使任何形式的字面量。
直接引用
直接引用可以使直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和迅疾的内存布局实现有关
解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行，分别对应于常量池的 7 中常量类型。

**6.2.5 初始化**

前面过程都是以虚拟机主导，而初始化阶段**开始执行类中的 Java 代码****。

**类的创建实例化对象过程：**

**1.通过类的全路径类名来获得这个类的二进制字节流（类加载器）**

**2.通过类加载器创建这个类的java.lang.Class类**（为这个类生成Class/Method/Field等对象）

**3.验证这个类是否合法**

**4.准备：为这个类分配内存**

**5.验证：把常量池中的符号引用改成直接引用**

**6.初始化：调用类的初始化方法clinit()为静态变量赋予实际的值（例如将value赋值为123）、执行静态代码块。**

**7.使用：**

​      **1.创建一个类的对象(new)**

​      **2.检查常量池的符号引用，检查这个类是否已经被加载，初始化过，如果没有执行类加载过程（从1开始执行）**

​      **3.准备阶段。通过实例化的类为对象分配内存空间**

​      **4.初始化为0，填充对象头**

​      **5.执行初始化方法**

**8.卸载**

jvm类存模型：

​    1.虚拟机方法栈：线程私有。每个方法对应一个栈帧

​    2.堆：存储对象。线程共享（对象：对象头+对象数据+填充对齐）

​         ![img](https://img2018.cnblogs.com/blog/1266638/201809/1266638-20180915171018654-463148519.png)

​    3.方法区：类的相关信息，常量池

​               ![img](https://img2018.cnblogs.com/blog/1266638/201809/1266638-20180915171332951-925981696.png)

   4.本地方法区   

   5.PC寄存器



  

6.3 类加载器

**通过一个类的全限定名来获取描述此类的二进制字节流**。

 6.3.1 双亲委派模型

从 Java 虚拟机角度讲，只存在两种类加载器：一种是启动类加载器（C++ 实现，是虚拟机的一部分）；另一种是其他所有类的加载器（Java 实现，独立于虚拟机外部且全继承自 java.lang.ClassLoader）

启动类加载器
加载 lib 下或被 -Xbootclasspath 路径下的类

扩展类加载器
加载 lib/ext 或者被 java.ext.dirs 系统变量所指定的路径下的类

引用程序类加载器
ClassLoader负责，加载用户路径上所指定的类库。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYzQyNzA0NzNjNDJjNGE1ZDE0ZWI0NzRjOGQ5NTcwZWI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

 

除顶层启动类加载器之外，其他都有自己的父类加载器。
工作过程：如果一个类加载器收到一个类加载的请求，它首先不会自己加载，而是把这个请求委派给父类加载器。只有父类无法完成时子类才会尝试加载。

6.3.2 破坏双亲委派模型

keyword：线程上下文加载器(Thread Context ClassLoader)

最后
前面两次粗略的阅读，能理解内容，但是很难记住细节。每每碰到不会的知识点就上网查，所以知识点太碎片脑子里没有体系不仅更不容易记住，而且更加容易混乱。但是通过这种方式记录发现自己清晰了很多，就算以后忘记，知识再次捡起的成本也低了很多。

这次还有一些章节虽然阅读了，但是还未完成记录。等自己理解深刻有空闲了就再次记录下来，这里的内容均出自周志明老师的《深入理解 Java 虚拟机》，有兴趣的可以入手纸质版。

**深入浅出JVM调优**
基本概念：

JVM把内存区分为堆区(heap)、栈区(stack)和方法区(method)。由于本文主要讲解JVM调优，因此我们可以简单的理解为，JVM中的堆区中存放的是实际的对象，是需要被GC的。其他的都无需GC。

下图文JVM（堆内存）的内存模型

![深入浅出JVM调优，看完你就懂](https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzJmNjdmYzQzMWE5NzQ4ODk5OWNiNWNlMzQ4ZjNjMzA5)



 

从图中我们可以看到，

1、JVM实质上分为三大块，年轻代(YoungGen)，年老代(Old Memory)，及持久代(Perm，在Java8中被取消，我们不做深入介绍)。

2、垃圾回收GC，分为2种，一是Minor GC，可以可以称为YGC，即年轻代GC，当Eden区，还有一种称为Major GC，又称为FullGC。

3、GC原理：

我们可以看到年轻代包括Eden区(对象刚被new出来的时候，放到该区)，S0和S1，是幸存者1区和幸存者2区，从名字可以看出，是当发生YGC，没有被任何其他对象所引用的对象将会从内存中被清除，还被其他对象引用的则放到幸存者区。当发生多次YGC，在S0、S1区多次没有被清楚的对象，则会被移到老年代区域。当老年代区域被占满的时候，则会发送FullGC。

无论是YGC或是FullGC，都会导致stop-the-world，即整个程序停止一些事务的处理，只有GC进程允许以进行垃圾回收，因此如果垃圾回收时间较长，部分web或socket程序，当终端连接的时候会报connetTimeOut或readTimeOut异常，

4、从JVM调优的角度来看，我们应该尽量避免发生YGC或FullGC，或者使得YGC和FullGC的时间足够的短。

JMV调优的准备工作。

1)、配置jstatd的远程RMI服务（当我们要看远程服务器上JAVA程序的GC情况的时候，需要执行此步骤），允许JVM工具查看JVM使用情况。

将如下的代码存为文件 jstatd.all.policy，放到JAVA_HOME/bin中，其内容如下：不知道JAVA_HOME目录的，可以执行 which java查看。

grant codebase "file:${java.home}/../lib/tools.jar" {

permission java.security.AllPermission;

};

执行命令jstatd -J-Djava.security.policy=jstatd.all.policy -J-Djava.rmi.server.hostname=10.27.20.38 &

(10.27.20.38为你服务器的ip地址,&表示用守护线程的方式运行)

2)、执行C:\glassfish4\jdk7\bin\jvisualvm.exe 打开JVM控制台。

工具--插件--中找到Visual GC插件进行安装.

3)、对要执行java程序进行调优，以 c1000k.jar为例，在该jar包所在目录下建立一个start.sh文件，文件内容如下。

java -server -Xms4G -Xmx4G -Xmn2G -XX:SurvivorRatio=1 -XX:+UseConcMarkSweepGC -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1100 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -jar c1000k.jar&

通过这样的配置，使用JVM控制台即可查看JVM(CPU/内存)及垃圾回收的情况。

4)、控制台配置

打开\jvisualvm.exe，远程---添加远程主机---输入远程IP----添加JMX连接

![深入浅出JVM调优，看完你就懂](https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2VmN2ZhMzI1ZTcxNzRmZTRiZWI0ODk2MDRhY2U2YzQ4)

 

5)、下面开始正式的JVM调优。

5.1 JVM调优核心为**调整年轻代、年老大的内存空间大小及使用GC发生器的类型**等。回到上文的start.sh文件内容，我们来分下：

java -server -Xms4G -Xmx4G -Xmn2G -XX:SurvivorRatio=1 -XX:+UseConcMarkSweepGC -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1100 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -jar c1000k.jar&

这台机器是一个4G内存的机器，因此：

-Xms4G 是指： JVM启动时整个堆(包括年轻代，年老代)的初始化大小。

-Xmx4G 是指： JVM启动时整个堆的最大值。

-Xmn2G是指：年轻代的空间大小，剩下的是年老代的空间。

-XX:SurvivorRatio=1是指：年轻代空间中2个Survivor空间与Eden空间的大小比例。此处为1:1:1，算法如下：比如整个年轻代空间为2G，如果比例为1，那么2/3，则S0/S1/Eden的空间大小是同样的，为666M。

该值不设置，则JDK默认为比例为8，那么是1:1:8，通过上面的算法可以得出S0/S1的大小。我们可以看到官方通过增大Eden区的大小，来减少YGC发生的次数，但有时我们发现，虽然次数减少了，但Eden区满

的时候，由于占用的空间较大，导致释放缓慢，此时stop-the-world的时间较长，因此需要按照程序情况去调优。

-XX:+UseConcMarkSweepGC是指：使用GC的回收类型。这里是CMS类型，JDK1.7以后推荐使用+UseG1GC，被称为G1类型(或Garbage First)的回收器。

5.2当我们设定好start.sh的参数值后，执行./start.sh此时就启动了。

我们可以通过jvisualvm.exe中的Visual GC插件查看GC的图形，我们也可以再服务器上执行：jstat -gc 15016 1000，看到每1秒钟java进程号为15016的GC回收情况。

[root@yxdevapp04 c1000k]# jstat -gc 15016 1000

S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT

699008.0 699008.0 29980.4 0.0 699136.0 116881.6 2097152.0 660769.4 21248.0 20071.0 354 54.272 0 0.000 54.272

699008.0 699008.0 29980.4 0.0 699136.0 118344.8 2097152.0 660769.4 21248.0 20071.0 354 54.272 0 0.000 54.272

699008.0 699008.0 29980.4 0.0 699136.0 119895.5 2097152.0 660769.4 21248.0 20071.0 354 54.272 0 0.000 54.272

699008.0 699008.0 29980.4 0.0 699136.0 121383.1 2097152.0 660769.4 21248.0 20071.0 354 54.272 0 0.000 54.272

解释如下：

S0C 是指：Survivor0区的分配空间

S0U 是指：Survivor1区的已经使用的空间

EC是指:Eden区所使用的空间

EU是指：Eden区当前使用的空间

OC是指：老年代分配的空间

OU是指：老年代当前使用的空间

PC是指：持久待分配的空间

PU是指：持久待当前使用的空间

YGC是指：年轻代发生的次数，这里是354次

YGCT是指：年轻代发送的总时长，这里是54.272秒，因此每次年轻代发生GC，即平均每次stop-the-world的时长为54.272/354=0.153秒。

FGC是指：年老代回收的次数，或者成为FullGC的次数。

FGCT是指：年老代发生回收的总时长。

GCT是指：包括年轻代YGC及年老代FGC的总时间长。

通常结合图形或数据，我们可以看到当EU即将等于EC的时候，此时发生YGC，因此YGC次数+1，YGCT时间增加。

经过实际的调优测试我们发现，当发生YGC的时候，如果S0U或S1U区如果有任意一个区域为0的时候，此时YGC的速度很快，相反如果S0U或者S1U中都有数据，或相对满的时候，此时YGC的时间边长，这就是因为S0/S1及Eden区的比例问题导致的。

5.3经过一定时间的调优，我们基本上可以使得YGC的次数非常少，时间非常快，很长时间，数天都不会发生FGC，此时JVM的调优算是一个好的结果。

5.4 在MAC电脑上可以通过jconsole调出图形化分析工具。

# 4 spring MVC aop jpa

## 1.aop

1. :切面编程：典型实现：日志系统  

<img src="https://static.oschina.net/uploads/img/201607/03162132_tup3.jpg" alt="4" style="zoom:50%;" />

| Before（前置通知）          | 目标方法调用之前执行   |
| --------------------------- | ---------------------- |
| After（后置通知）           | 目标方法调用之后执行   |
| After-returning（返回通知） | 目标方法执行成功后执行 |
| After-throwing（异常通知）  | 目标方法抛出异常后执行 |
| Around（环绕通知）          |                        |

把切点和通知合在一起就是切面了，一个切面指定了在何时何地执行何种方法。在spring aop中如此定义这个切面：

```java
@Aspect



@Component



public class UserAspect {



 



    @Before("execution(* com.aop.service.impl.UserServiceImpl.login(..))")



    public void loginLog(){



        System.out.println("user login");



    }



 



}1
```

使用注解@Aspect将某个特定的类声明为切面，这样，该类下的方法就可以声明为横向的功能点后插入到指定位置。使用execution表达式声明在这个切点，格式如下 ![5](https://static.oschina.net/uploads/img/201607/03162151_uRae.jpg)

第一个位置指定了方法的返回值，*号代表任意类型的返回值，然后是所在的类和方法名，*号同样代表任意，就是该类中任意的方法，在上一个例子中方法名是login，则是指定了该类中的login方法。然后最后一个参数是方法入参，因为java中支持重载，所以这个参数可以帮助你更精确的进行定位。两点表示任意参数类型。这样，execution表达式告诉了程序该在何地执行通知。而被诸如@Before注解修饰的方法就是通知的内容，也就是做什么。

至此，我们就可以使用spring aop，但是还有两点需要得到注意

1. 将切面类声明为一个bean

2. 切点指定的方法所在的类也同样需由spring注入才能生效、

3. *内容大纲：*

   - 描述一下Spring AOP？
   - 在Spring AOP中关注点(concern)和横切关注点(cross-cutting concern)有什么不同？
   - AOP有哪些可用的实现？
   - Spring中有哪些不同的通知类型(advice types)？
   - Spring AOP 代理是什么？//java动态代理只能是接口 因为他继承了Proxy类 只能实现接口了
   - 引介(Introduction)是什么？
   - 连接点(Joint Point)和切入点(Point Cut)是什么？
   - 织入（Weaving）是什么？

   描述一下Spring AOP

   Spring AOP(Aspect Oriented Programming，面向切面编程)是OOPs(面向对象编程)的补充，它也提供了模块化。在面向对象编程中，关键的单元是对象，AOP的关键单元是切面，或者说关注点（可以简单地理解为你程序中的独立模块）。一些切面可能有集中的代码，但是有些可能被分散或者混杂在一起，例如日志或者事务。**这些分散的切面被称为横切关注点**。一个横切关注点是一个可以影响到整个应用的关注点，而且应该被尽量地集中到代码的一个地方，例如事务管理、权限、日志、安全等。
   AOP让你可以使用简单可插拔的配置，在实际逻辑执行之前、之后或周围动态添加横切关注点。这让代码在当下和将来都变得易于维护。如果你是使用XML来使用切面的话，要添加或删除关注点，你不用重新编译完整的源代码，而仅仅需要修改配置文件就可以了。
   Spring AOP通过以下两种方式来使用。但是最广泛使用的方式是Spring AspectJ 注解风格(Spring AspectJ Annotation Style)

   - 使用AspectJ 注解风格
   - 使用Spring XML 配置风格

   在Spring AOP中关注点和横切关注点有什么不同？

   **关注点是我们想在应用的模块中实现的行为**。关注点可以被定义为：我们想实现以解决特定业务问题的方法。比如，在所有电子商务应用中，不同的关注点（或者模块）可能是库存管理、航运管理、用户管理等。
   **横切关注点是贯穿整个应用程序的关注点**。像日志、安全和数据转换，它们在应用的每一个模块都是必须的，所以他们是一种横切关注点。

   AOP有哪些可用的实现？

   基于Java的主要AOP实现有：

   1. AspectJ
   2. Spring AOP
   3. JBoss AOP

   在维基百科上你可以找到一个[AOP实现的大列表](https://en.wikipedia.org/wiki/Aspect-oriented_programming#Implementations)。

   Spring中有哪些不同的通知类型

   通知(advice)是你在你的程序中想要应用在其他模块中的横切关注点的实现。Advice主要有以下5种类型：

   1. **前置通知(Before Advice)**: 在连接点之前执行的Advice，不过除非它抛出异常，否则没有能力中断执行流。使用 `@Before` 注解使用这个Advice。
   2. **返回之后通知(After Retuning Advice)**: 在连接点正常结束之后执行的Advice。例如，如果一个方法没有抛出异常正常返回。通过 `@AfterReturning` 关注使用它。
   3. **抛出（异常）后执行通知(After Throwing Advice)**: 如果一个方法通过抛出异常来退出的话，这个Advice就会被执行。通用 `@AfterThrowing` 注解来使用。
   4. **后置通知(After Advice)**: 无论连接点是通过什么方式退出的(正常返回或者抛出异常)都会执行在结束后执行这些Advice。通过 `@After` 注解使用。
   5. **围绕通知(Around Advice)**: 围绕连接点执行的Advice，就你一个方法调用。这是最强大的Advice。通过 `@Around` 注解使用。

   Spring AOP 代理是什么？

   代理是使用非常广泛的设计模式。简单来说，**代理是一个看其他像另一个对象的对象，但它添加了一些特殊的功能**。
   Spring AOP是基于代理实现的。**AOP 代理是一个由 AOP 框架创建的用于在运行时实现切面协议的对象**。
   Spring AOP默认为 AOP 代理使用标准的 JDK 动态代理。这使得任何接口（或者接口的集合）可以被代理。Spring AOP 也可以使用 CGLIB 代理。这对代理类而不是接口是必须的。
   **如果业务对象没有实现任何接口那么默认使用CGLIB**。

   引介(Introduction)是什么？

   **引介让一个切面可以声明被通知的对象实现了任何他们没有真正实现的额外接口**，而且为这些对象提供接口的实现
   使用 `@DeclareParaents` 注解来生成一个引介。
   更多详情，请参考 [官方文档](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop)

   # 连接点(Joint Point)和切入点(Point cut)是什么？

   连接点是程序执行的一个点。例如，一个方法的执行或者一个异常的处理。在 Spring AOP 中，**一个连接点总是代表一个方法执行**。举例来说，所有定义在你的 `EmpoyeeManager` 接口中的方法都可以被认为是一个连接点，如果你在这些方法上使用横切关注点的话。
   **切入点(切入点)是一个匹配连接点的断言或者表达式**。Advice 与切入点表达式相关联，并在切入点匹配的任何连接点处运行（比如，表达式 `execution(* EmployeeManager.getEmployeeById(...))` 可以匹配 `EmployeeManager` 接口的 `getEmployeeById()` ）。由切入点表达式匹配的连接点的概念是 AOP 的核心。Spring 默认使用 AspectJ 切入点表达式语言。

   # 什么是织入(weaving)？

   **Spring AOP 框架仅支持有限的几个 AspectJ 切入点的类型，它允许将切面运用到在 IoC 容器中声明的 bean 上。如果你想使用额外的切入点类型或者将切面应用到在 Spring IoC 容器外部创建的类，那么你必须在你的 Spring 程序中使用 AspectJ 框架，并且使用它的织入特性。**
   织入是将切面与外部的应用类型或者类连接起来以创建通知对象(adviced object)的过程。这可以在编译时(比如使用 AspectJ 编译器)、加载时或者运行时完成。Spring AOP 跟其他纯 Java AOP 框架一样，只在运行时执行织入。在协议上，AspectJ 框架支持编译时和加载时织入。
   AspectJ 编译时织入是通过一个叫做 ***ajc*** 特殊的 AspectJ 编译器完成的。它可以将切面织入到你的 Java 源码文件中，然后输出织入后的二进制 class 文件。它也可以将切面织入你的编译后的 class 文件或者 Jar 文件。这个过程叫做后编译时织入(post-compile-time weaving)。在 Spring IoC 容器中声明你的类之前，你可以为它们运行编译时和后编译时织入。Spring 完全没有被包含到织入的过程中。更多关于编译时和后编译时织入的信息，请查阅 AspectJ 文档。
   AspectJ 加载时织入(load-time weaving, LTW)在目标类被类加载器加载到JVM时触发。对于一个被织入的对象，需要一个特殊的类加载器来增强目标类的字节码。AspectJ 和 Spring 都提供了加载时织入器以为类加载添加加载时织入的能力。你只需要简单的配置就可以打开这个加载时织入器。
   现在轮到你来分享更多你上次面试时遇到的 **Spring AOP 面试题**了，那样我可以把它们都加入到这个帖子里，使它对于其他人也更加有用。

4. # JAVA动态代理

   [![img](https://upload.jianshu.io/users/upload_avatars/2109481/3d7dbed1-d42a-4812-9cd5-bd083dd1ba1c.jpeg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)](https://www.jianshu.com/u/589a52fcab37)

   [只是肿态度](https://www.jianshu.com/u/589a52fcab37)关注

   0.2732019.05.12 23:25:39字数 964阅读 15,235

   ## 代理模式

   为其他对象提供一个代理以控制对某个对象的访问。代理类主要负责为委托了（真实对象）**预处理消息、过滤消息、传递消息给委托类**，**代理类不现实具体服务**，而是利用委托类来完成服务，并将执行结果封装处理。

   其实就是代理类为被代理类预处理消息、过滤消息并在此之后将消息转发给被代理类，之后还能进行消息的后置处理。代理类和被代理类通常会存在关联关系(即上面提到的持有的被带离对象的引用)，代理类本身不实现服务，而是通过调用被代理类中的方法来提供服务。

   ## 静态代理

   创建一个接口，然后创建被代理的类实现该接口并且实现该接口中的抽象方法。之后再创建一个代理类，同时使其也实现这个接口。在代理类中持有一个被代理对象的引用，而后在代理类方法中调用该对象的方法。

   接口：

   

   ```csharp
   public interface HelloInterface {
       void sayHello();
   }
   ```

   被代理类：

   

   ```java
   public class Hello implements HelloInterface{
       @Override
       public void sayHello() {
           System.out.println("Hello zhanghao!");
       }
   }
   ```

   代理类：

   

   ```java
   public class HelloProxy implements HelloInterface{
       private HelloInterface helloInterface = new Hello();
       @Override
       public void sayHello() {
           System.out.println("Before invoke sayHello" );
           helloInterface.sayHello();
           System.out.println("After invoke sayHello");
       }
   }
   ```

   代理类调用：
   被代理类被传递给了代理类HelloProxy，代理类在执行具体方法时通过所持用的被代理类完成调用。

   

   ```cpp
       public static void main(String[] args) {
           HelloProxy helloProxy = new HelloProxy();
           helloProxy.sayHello();
       }
       
   输出：
   Before invoke sayHello
   Hello zhanghao!
   After invoke sayHello
   ```

   使用静态代理很容易就完成了对一个类的代理操作。但是静态代理的缺点也暴露了出来：由于代理只能为一个类服务，如果需要代理的类很多，那么就需要编写大量的代理类，比较繁琐。

   ## 动态代理

   利用反射机制在运行时创建代理类。
   接口、被代理类不变，我们构建一个handler类来实现InvocationHandler接口。

   

   ```java
   public class ProxyHandler implements InvocationHandler{
       private Object object;
       public ProxyHandler(Object object){
           this.object = object;
       }
       @Override
       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
           System.out.println("Before invoke "  + method.getName());
           method.invoke(object, args);//java反射invoke
           System.out.println("After invoke " + method.getName());
           return null;
       }
   }
   ```

   执行动态代理：

   

   ```java
       public static void main(String[] args) {
           System.getProperties().setProperty("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");
   
           HelloInterface hello = new Hello();
           
           InvocationHandler handler = new ProxyHandler(hello);
   
           HelloInterface proxyHello = (HelloInterface) Proxy.newProxyInstance(hello.getClass().getClassLoader(), hello.getClass().getInterfaces(), handler);
   
           proxyHello.sayHello();
       }
       输出：
       Before invoke sayHello
       Hello zhanghao!
       After invoke sayHello
   ```

   通过Proxy类的静态方法newProxyInstance返回一个接口的代理实例。针对不同的代理类，传入相应的代理程序控制器InvocationHandler。
   如果新来一个被代理类Bye，如：

   

   ```java
   public interface ByeInterface {
       void sayBye();
   }
   public class Bye implements ByeInterface {
       @Override
       public void sayBye() {
           System.out.println("Bye zhanghao!");
       }
   }
   ```

   那么执行过程：

   

   ```jsx
       public static void main(String[] args) {
           System.getProperties().setProperty("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");
   
           HelloInterface hello = new Hello();
           ByeInterface bye = new Bye();
   
           InvocationHandler handler = new ProxyHandler(hello);
           InvocationHandler handler1 = new ProxyHandler(bye);
   
           HelloInterface proxyHello = (HelloInterface) Proxy.newProxyInstance(hello.getClass().getClassLoader(), hello.getClass().getInterfaces(), handler);
   
           ByeInterface proxyBye = (ByeInterface) Proxy.newProxyInstance(bye.getClass().getClassLoader(), bye.getClass().getInterfaces(), handler1);
           proxyHello.sayHello();
           proxyBye.sayBye();
       }
       输出：
       Before invoke sayHello
       Hello zhanghao!
       After invoke sayHello
       Before invoke sayBye
       Bye zhanghao!
       After invoke sayBye
   ```

   ## 动态代理底层实现

   动态代理具体步骤：

   1. 通过实现 InvocationHandler 接口创建自己的调用处理器；
   2. 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；
   3. 通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；
   4. 通过构造函数创建动态代理类实例，构传入。

   既然生成代理对象是用的Proxy类的静态方newProxyInstance，那么我们就去它的源码里看一下它到底都做了些什么？

   

   ```java
       public static Object newProxyInstance(ClassLoader loader,
                                             Class<?>[] interfaces,
                                             InvocationHandler h)
           throws IllegalArgumentException
       {
           Objects.requireNonNull(h);
   
           final Class<?>[] intfs = interfaces.clone();
           final SecurityManager sm = System.getSecurityManager();
           if (sm != null) {
               checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
           }
            //生成代理类对象
           Class<?> cl = getProxyClass0(loader, intfs);
   
           //使用指定的调用处理程序获取代理类的构造函数对象
           try {
               if (sm != null) {
                   checkNewProxyPermission(Reflection.getCallerClass(), cl);
               }
   
               final Constructor<?> cons = cl.getConstructor(constructorParams);
               final InvocationHandler ih = h;
               //如果Class作用域为私有，通过 setAccessible 支持访问
               if (!Modifier.isPublic(cl.getModifiers())) {
                   AccessController.doPrivileged(new PrivilegedAction<Void>() {
                       public Void run() {
                           cons.setAccessible(true);
                           return null;
                       }
                   });
               }
               //获取Proxy Class构造函数，创建Proxy代理实例。
               return cons.newInstance(new Object[]{h});
           } catch (IllegalAccessException|InstantiationException e) {
               throw new InternalError(e.toString(), e);
           } catch (InvocationTargetException e) {
               Throwable t = e.getCause();
               if (t instanceof RuntimeException) {
                   throw (RuntimeException) t;
               } else {
                   throw new InternalError(t.toString(), t);
               }
           } catch (NoSuchMethodException e) {
               throw new InternalError(e.toString(), e);
           }
       }
   ```

   利用getProxyClass0(loader, intfs)生成代理类Proxy的Class对象。

   

   ```java
       private static Class<?> getProxyClass0(ClassLoader loader,
                                              Class<?>... interfaces) {
           //如果接口数量大于65535，抛出非法参数错误
           if (interfaces.length > 65535) {
               throw new IllegalArgumentException("interface limit exceeded");
           }
   
          
           //如果指定接口的代理类已经存在与缓存中，则不用新创建，直接从缓存中取即可；
           //如果缓存中没有指定代理对象，则通过ProxyClassFactory来创建一个代理对象。
           return proxyClassCache.get(loader, interfaces);
       }
   ```

   ProxyClassFactory内部类创建、定义代理类，返回给定ClassLoader 和interfaces的代理类。

   

   ```java
           private static final class ProxyClassFactory
           implements BiFunction<ClassLoader, Class<?>[], Class<?>>{
           // 代理类的名字的前缀统一为“$Proxy”
           private static final String proxyClassNamePrefix = "$Proxy";
   
           // 每个代理类前缀后面都会跟着一个唯一的编号，如$Proxy0、$Proxy1、$Proxy2
           private static final AtomicLong nextUniqueNumber = new AtomicLong();
   
           @Override
           public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {
   
               Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);
               for (Class<?> intf : interfaces) {
                   //验证类加载器加载接口得到对象是否与由apply函数参数传入的对象相同
                   Class<?> interfaceClass = null;
                   try {
                       interfaceClass = Class.forName(intf.getName(), false, loader);
                   } catch (ClassNotFoundException e) {
                   }
                   if (interfaceClass != intf) {
                       throw new IllegalArgumentException(
                           intf + " is not visible from class loader");
                   }
                   //验证这个Class对象是不是接口
                   if (!interfaceClass.isInterface()) {
                       throw new IllegalArgumentException(
                           interfaceClass.getName() + " is not an interface");
                   }
                   if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {
                       throw new IllegalArgumentException(
                           "repeated interface: " + interfaceClass.getName());
                   }
               }
   
               String proxyPkg = null;     // package to define proxy class in
               int accessFlags = Modifier.PUBLIC | Modifier.FINAL;
   
               /*
                * Record the package of a non-public proxy interface so that the
                * proxy class will be defined in the same package.  Verify that
                * all non-public proxy interfaces are in the same package.
                */
               for (Class<?> intf : interfaces) {
                   int flags = intf.getModifiers();
                   if (!Modifier.isPublic(flags)) {
                       accessFlags = Modifier.FINAL;
                       String name = intf.getName();
                       int n = name.lastIndexOf('.');
                       String pkg = ((n == -1) ? "" : name.substring(0, n + 1));
                       if (proxyPkg == null) {
                           proxyPkg = pkg;
                       } else if (!pkg.equals(proxyPkg)) {
                           throw new IllegalArgumentException(
                               "non-public interfaces from different packages");
                       }
                   }
               }
   
               if (proxyPkg == null) {
                   // if no non-public proxy interfaces, use com.sun.proxy package
                   proxyPkg = ReflectUtil.PROXY_PACKAGE + ".";
               }
   
               /*
                * Choose a name for the proxy class to generate.
                */
               long num = nextUniqueNumber.getAndIncrement();
               String proxyName = proxyPkg + proxyClassNamePrefix + num;
   
               /*
                * 
                * 生成指定代理类的字节码文件
                */
               byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
                   proxyName, interfaces, accessFlags);
               try {
                   return defineClass0(loader, proxyName,
                                       proxyClassFile, 0, proxyClassFile.length);
               } catch (ClassFormatError e) {
                   /*
                    * A ClassFormatError here means that (barring bugs in the
                    * proxy class generation code) there was some other
                    * invalid aspect of the arguments supplied to the proxy
                    * class creation (such as virtual machine limitations
                    * exceeded).
                    */
                   throw new IllegalArgumentException(e.toString());
               }
           }
       }
   ```

   一系列检查后，调用ProxyGenerator.generateProxyClass来生成字节码文件。

   

   ```csharp
     public static byte[] generateProxyClass(final String var0, Class<?>[] var1, int var2) {
           ProxyGenerator var3 = new ProxyGenerator(var0, var1, var2);
           // 真正用来生成代理类字节码文件的方法在这里
           final byte[] var4 = var3.generateClassFile();
           // 保存代理类的字节码文件
           if(saveGeneratedFiles) {
               AccessController.doPrivileged(new PrivilegedAction<Void>() {
                   public Void run() {
                       try {
                           int var1 = var0.lastIndexOf(46);
                           Path var2;
                           if(var1 > 0) {
                               Path var3 = Paths.get(var0.substring(0, var1).replace('.', File.separatorChar), new String[0]);
                               Files.createDirectories(var3, new FileAttribute[0]);
                               var2 = var3.resolve(var0.substring(var1 + 1, var0.length()) + ".class");
                           } else {
                               var2 = Paths.get(var0 + ".class", new String[0]);
                           }
   
                           Files.write(var2, var4, new OpenOption[0]);
                           return null;
                       } catch (IOException var4x) {
                           throw new InternalError("I/O exception saving generated file: " + var4x);
                       }
                   }
               });
           }
   
           return var4;
       }
   ```

   生成代理类字节码文件的generateClassFile方法:

   

   ```kotlin
       private byte[] generateClassFile() {
           //下面一系列的addProxyMethod方法是将接口中的方法和Object中的方法添加到代理方法中(proxyMethod)
           this.addProxyMethod(hashCodeMethod, Object.class);
           this.addProxyMethod(equalsMethod, Object.class);
           this.addProxyMethod(toStringMethod, Object.class);
           Class[] var1 = this.interfaces;
           int var2 = var1.length;
   
           int var3;
           Class var4;
           //获得接口中所有方法并添加到代理方法中
           for(var3 = 0; var3 < var2; ++var3) {
               var4 = var1[var3];
               Method[] var5 = var4.getMethods();
               int var6 = var5.length;
   
               for(int var7 = 0; var7 < var6; ++var7) {
                   Method var8 = var5[var7];
                   this.addProxyMethod(var8, var4);
               }
           }
   
           Iterator var11 = this.proxyMethods.values().iterator();
   
           List var12;
           while(var11.hasNext()) {
               var12 = (List)var11.next();
               checkReturnTypes(var12);
           }
   
           Iterator var15;
           try {
               //生成代理类的构造函数
               this.methods.add(this.generateConstructor());
               var11 = this.proxyMethods.values().iterator();
   
               while(var11.hasNext()) {
                   var12 = (List)var11.next();
                   var15 = var12.iterator();
                       
                   while(var15.hasNext()) {
                       ProxyGenerator.ProxyMethod var16 = (ProxyGenerator.ProxyMethod)var15.next();
                       this.fields.add(new ProxyGenerator.FieldInfo(var16.methodFieldName, "Ljava/lang/reflect/Method;", 10));
                       this.methods.add(var16.generateMethod());
                   }
               }
   
               this.methods.add(this.generateStaticInitializer());
           } catch (IOException var10) {
               throw new InternalError("unexpected I/O Exception", var10);
           }
   
           if(this.methods.size() > '\uffff') {
               throw new IllegalArgumentException("method limit exceeded");
           } else if(this.fields.size() > '\uffff') {
               throw new IllegalArgumentException("field limit exceeded");
           } else {
               this.cp.getClass(dotToSlash(this.className));
               this.cp.getClass("java/lang/reflect/Proxy");
               var1 = this.interfaces;
               var2 = var1.length;
   
               for(var3 = 0; var3 < var2; ++var3) {
                   var4 = var1[var3];
                   this.cp.getClass(dotToSlash(var4.getName()));
               }
   
               this.cp.setReadOnly();
               ByteArrayOutputStream var13 = new ByteArrayOutputStream();
               DataOutputStream var14 = new DataOutputStream(var13);
   
               try {
                   var14.writeInt(-889275714);
                   var14.writeShort(0);
                   var14.writeShort(49);
                   this.cp.write(var14);
                   var14.writeShort(this.accessFlags);
                   var14.writeShort(this.cp.getClass(dotToSlash(this.className)));
                   var14.writeShort(this.cp.getClass("java/lang/reflect/Proxy"));
                   var14.writeShort(this.interfaces.length);
                   Class[] var17 = this.interfaces;
                   int var18 = var17.length;
   
                   for(int var19 = 0; var19 < var18; ++var19) {
                       Class var22 = var17[var19];
                       var14.writeShort(this.cp.getClass(dotToSlash(var22.getName())));
                   }
   
                   var14.writeShort(this.fields.size());
                   var15 = this.fields.iterator();
   
                   while(var15.hasNext()) {
                       ProxyGenerator.FieldInfo var20 = (ProxyGenerator.FieldInfo)var15.next();
                       var20.write(var14);
                   }
   
                   var14.writeShort(this.methods.size());
                   var15 = this.methods.iterator();
   
                   while(var15.hasNext()) {
                       ProxyGenerator.MethodInfo var21 = (ProxyGenerator.MethodInfo)var15.next();
                       var21.write(var14);
                   }
   
                   var14.writeShort(0);
                   return var13.toByteArray();
               } catch (IOException var9) {
                   throw new InternalError("unexpected I/O Exception", var9);
               }
           }
       }
   ```

   字节码生成后，调用defineClass0来解析字节码，生成了Proxy的Class对象。在了解完代理类动态生成过程后，生产的代理类是怎样的，谁来执行这个代理类。

   其中，在ProxyGenerator.generateProxyClass函数中 saveGeneratedFiles定义如下，其指代是否保存生成的代理类class文件，默认false不保存。

   在前面的示例中，我们修改了此系统变量：

   

   ```css
   System.getProperties().setProperty("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");
   ```

   ![img](https://upload-images.jianshu.io/upload_images/2109481-c68c854238142932.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

   image.png

   如图，生成了两个名为 ![Proxy0.class、](https://math.jianshu.com/math?formula=Proxy0.class%E3%80%81)Proxy1.class的class文件。

   动态代理流程图：

   

   ![img](https://upload-images.jianshu.io/upload_images/2109481-5bc36d36f5997da1.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

## 2.spring（设计模式）

 Spring IOC  工厂模式(解决接口具体使用那个实现类的问题)、

​                                   单例模式、保证一个类仅有一个实例，并提供一个访问它的全局访问点（一个全局使用的类频繁地创建与销毁）

​                                     装饰器模式**（允许向一个现有的对象添加新的功能，同时又不改变其结构）

　　         **2、Spring AOP 代理模式（在代理模式（Proxy Pattern）中，一个类代表另一个类的功能）、**

​                                       **观察者模式 **（定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。）

　　        **3、Spring MVC 委派模式、适配器模式**（是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能）

　          　**4、Spring JDBC 模板方法模式**

jpa

## 3.spring ioc

#####    1spring 解决循环依赖:3级缓存

​                    那种循环依赖不能解决（不能解决构造器依赖注入，能解决get/set的依赖注入） 

​                    多例为什么不能解决循环依赖（多例不使用缓存，所以不能解决）

  spring bean创建 --getBeans-doGetBeans--createBeans(创建早期bean)--放入3级缓存池--依赖问题解决---初始化bean--放入单例缓存池--结束

​    2 spring 事务

​    bean的生命周期：单例：随着spring容器创建时而创建，spring容器存在就一直存在，spring容器不    存在则销毁

​                                     多例：对象使用时创建，使用时存在，最后会由gc负责销毁

##### spring启动流程：

​     1.调用它的构造方法--创建了BeanFactoy（this();）(继承父类的方法)

​     2.创建spring自己需要的类，并加载配置类放入 BeanDefinition中组件中--

​    3.扫描bean,将bean的信息加入到BeanDefinition中（BeanDefinition是 

​          Map<String,Object>类型 还有一个含有类名称的list集合）并执行  

​           BeanFacoryPostProcessor方法

​    4.遍历名字集合获的Bean名称--getBean方法

​    5第一次调用单例池---单例池无对象--

​    6.开始创建对象---再次调用单例缓存池（设置正在创建标识）

---

​    7.new 一个对象（使用默认构造器new一个对象-（早期对象（属性还没有被赋值），并

​              将对象加入三级缓存池））

​    8.对象合并BeanDefinition（信息）

​    9.对象是否循环依赖

​    10.对象的后置处理（依赖注入--生命周期方法--aop处理）---

​     11.bean实例化并加入单例缓存池--结束

spring

new一个对象----aop----lifeclycallback--XXX----自动注入----xxx--bean

实例化----整个过程

初始化----当对象new 出来之后

spring后置处理器：自动注入 aop等功能都是用后置处理器来完成

A-implements-beanPostProcessor---插手初始化bean



1：实例化一个ApplicationContext的对象；
2：调用bean工厂后置处理器完成扫描；
3：循环解析扫描出来的类信息；
4：实例化一个BeanDefinition对象来存储解析出来的信息；
5：把实例化好的beanDefinition对象put到beanDefinitionMap当中缓存起来，以便后面实例化bean；
6：再次调用bean工厂后置处理器；
7：当然spring还会干很多事情，比如国际化，比如注册BeanPostProcessor等等，如果我们只关心如何实例化一个bean的话那么这一步就是spring调用finishBeanFactoryInitialization方法来实例化**单例的bean**，实例化之前spring要做验证，需要遍历所有扫描出来的类，依次判断这个bean是否Lazy，是否prototype，是否abstract等等；
8：如果验证完成spring在实例化一个bean之前需要推断构造方法，因为spring实例化对象是通过构造方法反射，故而需要知道用哪个构造方法；
9：推断完构造方法之后spring调用构造方法反射实例化一个对象；注意我这里说的是对象、对象、对象；这个时候对象已经实例化出来了，但是并不是一个完整的bean，最简单的体现是这个时候实例化出来**的对象属性是没有注入，所以不是一个完整的bean**；
10：spring处理合并后的beanDefinition(合并？是spring当中非常重要的一块内容，后面的文章我会分析)；
11：判断是否支持循环依赖，如果支持则提前把一个工厂存入singletonFactories——map；
12：判断是否需要完成属性注入
13：如果需要完成属性注入，则开始注入属性
14：判断bean的类型回调Aware接口
15：调用生命周期回调方法
16：如果需要代理则完成代理
17：put到单例池——bean完成——存在spring容器当中
用一个例子来证明上面的步骤

## 4.SpringMvc 

​     

- [@RequestMapping 注解：](https://www.cnblogs.com/nhdlb/p/11532643.html#_label0)
- [@RequestMapping 注解可以在控制器类的级别和/或其中的方法的级别上使用。 ](https://www.cnblogs.com/nhdlb/p/11532643.html#_label1)
- [@RequestMapping 来处理多个 URI ](https://www.cnblogs.com/nhdlb/p/11532643.html#_label2)
- [@RequestParam](https://www.cnblogs.com/nhdlb/p/11532643.html#_label3)
- [@RequestMapping属性：](https://www.cnblogs.com/nhdlb/p/11532643.html#_label4)
- [method ：](https://www.cnblogs.com/nhdlb/p/11532643.html#_label5)
- [produces：](https://www.cnblogs.com/nhdlb/p/11532643.html#_label6)
- [consumes：](https://www.cnblogs.com/nhdlb/p/11532643.html#_label7)
- [header：](https://www.cnblogs.com/nhdlb/p/11532643.html#_label8)
- [params ：](https://www.cnblogs.com/nhdlb/p/11532643.html#_label9)
- [@RequestMapping 快捷方式 ：](https://www.cnblogs.com/nhdlb/p/11532643.html#_label10)

 

**正文**

 

[回到顶部](https://www.cnblogs.com/nhdlb/p/11532643.html#_labelTop)

### **@RequestMapping 注解：**

@RequestMapping 是 Spring Web 应用程序中最常被用到的注解之一。这个注解会将 HTTP 请求映射到 MVC 和 REST 控制器的处理方法上。

Request Mapping 基础用法 

在 Spring MVC 应用程序中，RequestDispatcher (在 Front Controller 之下) 这个 servlet 负责将进入的 HTTP 请求路由到控制器的处理方法。 

在对 Spring MVC 进行的配置的时候, 你需要指定请求与处理方法之间的映射关系。 

![点击查看原始大小图片](http://dl2.iteye.com/upload/attachment/0126/9681/a35e51d6-789f-355e-92a1-e10144472ec6.png)

要配置 Web 请求的映射，就需要你用上 @RequestMapping 注解。 

 

[回到顶部](https://www.cnblogs.com/nhdlb/p/11532643.html#_labelTop)

### **@RequestMapping 注解可以在控制器类的级别和/或其中的方法的级别上使用。** 

在类的级别上的注解会将一个特定请求或者请求模式映射到一个控制器之上。之后你还可以另外添加方法级别的注解来进一步指定到处理方法的映射关系。 

下面是一个同时在类和方法上应用了 @RequestMapping 注解的示例： 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
@RestController  
@RequestMapping("/home")  
public class IndexController {  
    @RequestMapping("/")  
    String get() {  
        //mapped to hostname:port/home/  
        return "Hello from get";  
    }  
    @RequestMapping("/index")  
    String index() {  
        //mapped to hostname:port/home/index/  
        return "Hello from index";  
    }  
} 
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

如上述代码所示，到 /home 的请求会由 get() 方法来处理，而到 /home/index 的请求会由 index() 来处理。 

 

[回到顶部](https://www.cnblogs.com/nhdlb/p/11532643.html#_labelTop)

### **@RequestMapping 来处理多个 URI** 

你可以将多个请求映射到一个方法上去，只需要添加一个带有请求路径值列表的 @RequestMapping 注解就行了。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
@RestController  
@RequestMapping("/home")  
public class IndexController {  
  
    @RequestMapping(value = {  
        "",  
        "/page",  
        "page*",  
        "view/*,**/msg"  
    })  
    String indexMultipleMapping() {  
        return "Hello from index multiple mapping.";  
    }  
}  
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

如你在这段代码中所看到的，@RequestMapping 支持统配符以及ANT风格的路径。前面这段代码中，如下的这些 URL 都会由 indexMultipleMapping() 来处理： 

```
localhost:8080/home``localhost:8080/home/``localhost:8080/home/page``localhost:8080/home/pageabc``localhost:8080/home/view/``localhost:8080/home/view/view
```

　　

 

[回到顶部](https://www.cnblogs.com/nhdlb/p/11532643.html#_labelTop)

### **@RequestParam**

带有 @RequestParam 的 @RequestMapping 

@RequestParam 注解配合 @RequestMapping 一起使用，可以将请求的参数同处理方法的参数绑定在一起。 

@RequestParam 注解使用的时候可以有一个值，也可以没有值。这个值指定了需要被映射到处理方法参数的请求参数, 代码如下所示： 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
@RestController  
@RequestMapping("/home")  
public class IndexController {  
  
    @RequestMapping(value = "/id")  
    String getIdByValue(@RequestParam("id") String personId) {  
        System.out.println("ID is " + personId);  
        return "Get ID from query string of URL with value element";  
    }  
    @RequestMapping(value = "/personId")  
    String getId(@RequestParam String personId) {  
        System.out.println("ID is " + personId);  
        return "Get ID from query string of URL without value element";  
    }  
} 
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

@RequestParam 的 defaultValue 取值就是用来给取值为空的请求参数提供一个默认值的。 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
@RestController  
@RequestMapping("/home")  
public class IndexController {  
    @RequestMapping(value = "/name")  
    String getName(@RequestParam(value = "person", defaultValue = "John") String personName) {  
        return "Required element of request param";  
    }  
} 
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

在这段代码中，如果 person 这个请求参数为空，那么 getName() 处理方法就会接收 John 这个默认值作为其参数。 

 

 

[回到顶部](https://www.cnblogs.com/nhdlb/p/11532643.html#_labelTop)

### **@RequestMapping属性：**

[回到顶部](https://www.cnblogs.com/nhdlb/p/11532643.html#_labelTop)

### **method ：**

Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。 
所有的请求默认都会是 HTTP GET 类型的。 

对请求的映射不仅仅不局限在标示的方法的返回值对请求url上，还可以对请求的其属性做出约定，如请求的method，是get还是post。如果做出了method的条件限定，当请求的url即使映射上了，method不符合的话也不能生成物理视图并转发到目标页面。你需要在 @RequestMapping 中使用 method 来声明 HTTP 请求所使用的方法类型：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
@RestController  
@RequestMapping("/home")  
public class IndexController {  
    @RequestMapping(method = RequestMethod.GET)  
    String get() {  
        return "Hello from get";  
    }  
    @RequestMapping(method = RequestMethod.DELETE)  
    String delete() {  
        return "Hello from delete";  
    }  
    @RequestMapping(method = RequestMethod.POST)  
    String post() {  
        return "Hello from post";  
    }  
    @RequestMapping(method = RequestMethod.PUT)  
    String put() {  
        return "Hello from put";  
    }  
    @RequestMapping(method = RequestMethod.PATCH)  
    String patch() {  
        return "Hello from patch";  
    }  
} 
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

[回到顶部](https://www.cnblogs.com/nhdlb/p/11532643.html#_labelTop)

### **produces：**

它的作用是指定返回值类型，不但可以设置返回值类型还可以设定返回值的字符编码；

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
@Controller  
@RequestMapping(value = "/pets/{petId}", produces="MediaType.APPLICATION_JSON_VALUE"+";charset=utf-8")  
@ResponseBody  
public Pet getPet(@PathVariable String petId, Model model) {      
    // implementation omitted  
} 
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

[回到顶部](https://www.cnblogs.com/nhdlb/p/11532643.html#_labelTop)

### **consumes：**

 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
@Controller  
@RequestMapping(value = "/pets", method = RequestMethod.POST, consumes="application/json")  
public void addPet(@RequestBody Pet pet, Model model) {      
    // implementation omitted  
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

[回到顶部](https://www.cnblogs.com/nhdlb/p/11532643.html#_labelTop)

### **header：**

根据请求中的消息头内容缩小 请求映射 的范围；

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
@Controller
@RequestMapping("/owners/{ownerId}")
public class RelativePathUriTemplateController {

@RequestMapping(value = "/pets", method = RequestMethod.GET, headers="Referer=http://www.ifeng.com/")
  public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) {    
    // implementation omitted
  }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
@RestController  
@RequestMapping("/home")  
public class IndexController {  
    @RequestMapping(value = "/head", headers = {  
        "content-type=text/plain"  
    })  
    String post() {  
        return "Mapping applied along with headers";  
    }  
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
@RestController  
@RequestMapping("/home")  
public class IndexController {  
    @RequestMapping(value = "/head", headers = {  
        "content-type=text/plain",  
        "content-type=text/html"  
    }) String post() {  
        return "Mapping applied along with headers";  
    }  
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

[回到顶部](https://www.cnblogs.com/nhdlb/p/11532643.html#_labelTop)

### **params ：**

params 元素可以进一步帮助我们缩小请求映射的定位范围（定义传参的值，当值为定义的值时，进入方法运行，否则不运行）。使用 params 元素，你可以让多个处理方法处理到同一个URL 的请求, 而这些请求的参数是不一样的。你可以用 myParams = myValue 这种格式来定义参数，也可以使用通配符来指定特定的参数值在请求中是不受支持的。

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
@RestController  
@RequestMapping("/home")  
public class IndexController {  
    @RequestMapping(value = "/fetch", params = {  
        "personId=10"  
    })  
    String getParams(@RequestParam("personId") String id) {  
        return "Fetched parameter using params attribute = " + id;  
    }  
    @RequestMapping(value = "/fetch", params = {  
        "personId=20"  
    })  
    String getParamsDifferent(@RequestParam("personId") String id) {  
        return "Fetched parameter using params attribute = " + id;  
    }  
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

 

[回到顶部](https://www.cnblogs.com/nhdlb/p/11532643.html#_labelTop)

### **@RequestMapping 快捷方式 ：**

Spring 4.3 引入了方法级注解的变体，也被叫做 @RequestMapping 的组合注解。组合注解可以更好的表达被注解方法的语义。它们所扮演的角色就是针对 @RequestMapping 的封装，而且成了定义端点的标准方法。 
例如，@GetMapping 是一个组合注解，它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。 
方法级别的注解变体有如下几个： 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
@GetMapping
@PostMapping
@PutMapping
@DeleteMapping
@PatchMapping
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

如下代码展示了如何使用组合注解：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
@RestController  
@RequestMapping("/home")  
public class IndexController {  
    @GetMapping("/person")  
    public @ResponseBody ResponseEntity < String > getPerson() {  
        return new ResponseEntity < String > ("Response from GET", HttpStatus.OK);  
    }  
    @GetMapping("/person/{id}")  
    public @ResponseBody ResponseEntity < String > getPersonById(@PathVariable String id) {  
        return new ResponseEntity < String > ("Response from GET with id " + id, HttpStatus.OK);  
    }  
    @PostMapping("/person")  
    public @ResponseBody ResponseEntity < String > postPerson() {  
        return new ResponseEntity < String > ("Response from POST method", HttpStatus.OK);  
    }  
    @PutMapping("/person")  
    public @ResponseBody ResponseEntity < String > putPerson() {  
        return new ResponseEntity < String > ("Response from PUT method", HttpStatus.OK);  
    }  
    @DeleteMapping("/person")  
    public @ResponseBody ResponseEntity < String > deletePerson() {  
        return new ResponseEntity < String > ("Response from DELETE method", HttpStatus.OK);  
    }  
    @PatchMapping("/person")  
    public @ResponseBody ResponseEntity < String > patchPerson() {  
        return new ResponseEntity < String > ("Response from PATCH method", HttpStatus.OK);  
    }  
}  
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

在这段代码中，每一个处理方法都使用 @RequestMapping 的组合变体进行了注解。尽管每个变体都可以使用带有方法属性的 @RequestMapping 注解来互换实现, 但组合变体仍然是一种最佳的实践 — 这主要是因为组合注解减少了在应用程序上要配置的元数据，并且代码也更易读。 

Spring事务

​     [有关Spring事务，看这一篇就足够了](https://www.cnblogs.com/mseddl/p/11577846.html)

本文将按照声明式事务的五个特性进行介绍：

1. 事务传播机制
2. 事务隔离机制
3. 只读
4. 事务超时
5. 回滚规则

# Spring事务传播机制

## 事务的特性

- 原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。
- 一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。
- 隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。
- 持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。

## Spring事务的配置方式

Spring支持编程式事务管理以及声明式事务管理两种方式。

### 1. 编程式事务管理

编程式事务管理是侵入性事务管理，使用TransactionTemplate或者直接使用PlatformTransactionManager，对于编程式事务管理，Spring推荐使用TransactionTemplate。

### 2. 声明式事务管理

声明式事务管理建立在AOP之上，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，执行完目标方法之后根据执行的情况提交或者回滚。
编程式事务每次实现都要单独实现，但业务量大功能复杂时，使用编程式事务无疑是痛苦的，而声明式事务不同，声明式事务属于无侵入式，不会影响业务逻辑的实现，只需要在配置文件中做相关的事务规则声明或者通过注解的方式，便可以将事务规则应用到业务逻辑中。
显然声明式事务管理要优于编程式事务管理，这正是Spring倡导的非侵入式的编程方式。唯一不足的地方就是声明式事务管理的粒度是方法级别，而编程式事务管理是可以到代码块的，但是可以通过提取方法的方式完成声明式事务管理的配置。

## 事务的传播机制

事务的传播性一般用在**事务嵌套**的场景，比如**一个事务方法里面调用了另外一个事务方法**，那么两个方法是各自作为独立的方法提交还是内层的事务合并到外层的事务一起提交，这就是需要事务传播机制的配置来确定怎么样执行。
常用的事务传播机制如下：

- PROPAGATION_REQUIRED
  Spring默认的传播机制，能满足绝大部分业务需求，如果外层有事务，则当前事务加入到外层事务，一块提交，一块回滚。如果外层没有事务，新建一个事务执行
- PROPAGATION_REQUES_NEW
  该事务传播机制是每次都会新开启一个事务，同时把外层事务挂起，当当前事务执行完毕，恢复上层事务的执行。如果外层没有事务，执行当前新开启的事务即可
- PROPAGATION_SUPPORT
  如果外层有事务，则加入外层事务，如果外层没有事务，则直接使用非事务方式执行。完全依赖外层的事务
- PROPAGATION_NOT_SUPPORT
  该传播机制不支持事务，如果外层存在事务则挂起，执行完当前代码，则恢复外层事务，无论是否异常都不会回滚当前的代码
- PROPAGATION_NEVER
  该传播机制不支持外层事务，即如果外层有事务就抛出异常
- PROPAGATION_MANDATORY (mandatory 强制的; 法定的; 义务的)
- 与NEVER相反，如果外层没有事务，则抛出异常
- PROPAGATION_NESTED(nested 筑巢; 巢居; 嵌套)
  该传播机制的特点是可以保存状态保存点，当前事务回滚到某一个点，从而避免所有的嵌套事务都回滚，即各自回滚各自的，如果子事务没有把异常吃掉，基本还是会引起全部回滚的。

> 传播规则回答了这样一个问题：一个新的事务应该被启动还是被挂起，或者是一个方法是否应该在事务性上下文中运行。

# 事务的隔离级别

事务的隔离级别定义一**个事务可能受其他并发务活动活动影响的程度**，可以把事务的隔离级别想象为这个事务对于事物处理数据的自私程度。

在一个典型的应用程序中，多个事务同时运行，经常会为了完成他们的工作而操作同一个数据。并发虽然是必需的，但是会导致以下问题：

1. 脏读（Dirty read）
   脏读发生在一个事务读取了被另一个事务改写但尚未提交的数据时。如果这些改变在稍后被回滚了，那么第一个事务读取的数据就会是无效的。

2. 不可重复读（Nonrepeatable read）
   不可重复读发生在一个事务执行相同的查询两次或两次以上，但每次查询结果都不相同时。这通常是由于另一个并发事务在两次查询之间更新了数据。

   > 不可重复读重点在修改。

3. 幻读（Phantom reads）
   幻读和不可重复读相似。当一个事务（T1）读取几行记录后，另一个并发事务（T2）插入了一些记录时，幻读就发生了。在后来的查询中，第一个事务（T1）就会发现一些原来没有的额外记录。

   > 幻读重点在新增或删除。

在理想状态下，事务之间将完全隔离，从而可以防止这些问题发生。然而，完全隔离会影响性能，因为隔离经常涉及到锁定在数据库中的记录（甚至有时是锁表）。完全隔离要求事务相互等待来完成工作，会阻碍并发。因此，可以根据业务场景选择不同的隔离级别。

uncommitted:未作承诺的; 未表态的

repeatable:有礼貌; 不冒犯人; 可重复

serializable:可串行化的

| 隔离级别                   | 含义                                                         |
| -------------------------- | ------------------------------------------------------------ |
| ISOLATION_DEFAULT          | 使用后端数据库默认的隔离级别                                 |
| ISOLATION_READ_UNCOMMITTED | 允许读取尚未提交的更改。可能导致脏读、幻读或不可重复读。     |
| ISOLATION_READ_COMMITTED   | （Oracle 默认级别）允许从已经提交的并发事务读取。可防止脏读，但幻读和不可重复读仍可能会发生。 |
| ISOLATION_REPEATABLE_READ  | （MYSQL默认级别）对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻读仍可能发生。 |
| ISOLATION_SERIALIZABLE     | 完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。 |

# 只读

如果一个事务只对数据库执行读操作，那么该数据库就可能利用那个事务的只读特性，采取某些优化措施。通过把一个事务声明为只读，可以给后端数据库一个机会来应用那些它认为合适的优化措施。由于只读的优化措施是在一个事务启动时由后端数据库实施的， 因此，只有对于那些具有可能启动一个新事务的传播行为（PROPAGATION_REQUIRES_NEW、PROPAGATION_REQUIRED、 ROPAGATION_NESTED）的方法来说，将事务声明为只读才有意义。

# 事务超时

为了使一个应用程序很好地执行，它的事务不能运行太长时间。因此，声明式事务的下一个特性就是它的超时。

假设事务的运行时间变得格外的长，由于事务可能涉及对数据库的锁定，所以长时间运行的事务会不必要地占用数据库资源。这时就可以声明一个事务在特定秒数后自动回滚，不必等它自己结束。

由于超时时钟在一个事务启动的时候开始的，因此，只有对于那些具有可能启动一个新事务的传播行为（PROPAGATION_REQUIRES_NEW、PROPAGATION_REQUIRED、ROPAGATION_NESTED）的方法来说，声明事务超时才有意义。

# 回滚规则

在默认设置下，事务只在出现运行时异常（runtime exception）时回滚，而在出现受检查异常（checked exception）时不回滚（这一行为和EJB中的回滚行为是一致的）。
不过，可以声明在出现特定受检查异常时像运行时异常一样回滚。同样，也可以声明一个事务在出现特定的异常时不回滚，即使特定的异常是运行时异常。

# Spring声明式事务配置参考

事物配置中有哪些属性可以配置?以下只是简单的使用参考

1. 事务的传播性：
   @Transactional(propagation=Propagation.REQUIRED)
2. 事务的隔离级别：
   @Transactional(isolation = Isolation.READ_UNCOMMITTED)

> 读取未提交数据(会出现脏读, 不可重复读) 基本不使用

1. 只读：
   @Transactional(readOnly=true)
   该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。
2. 事务的超时性：
   @Transactional(timeout=30)
3. 回滚：
   指定单一异常类：@Transactional(rollbackFor=RuntimeException.class)
   指定多个异常类：@Transactional(rollbackFor={RuntimeException.class, Exception.class})

> 该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。

## 4.注解

​      使用@interface 自定义注解

转载：
在自定义注解之前首先要知晓一个东西：元注解- 可以理解为最根本的注解,其他的注解是可以用此来衍生的，作用就是负责注解其他注解。



```css
   在java  5中有几个元注解　
1.@Target
2.@Retention,
3.@Documented,
4.@Inherited
```



```css
@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。
```

作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）

取值(ElementType)有：

1.CONSTRUCTOR:用于描述构造器
　　　　2.FIELD:用于描述域
　　　　3.LOCAL_VARIABLE:用于描述局部变量
　　　　4.METHOD:用于描述方法
　　　　5.PACKAGE:用于描述包
　　　　6.PARAMETER:用于描述参数
　　　　7.TYPE:用于描述类、接口(包括注解类型) 或enum声明



```css
  @Retention：
```

@Retention定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。

作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）

取值（RetentionPoicy）有：

1.SOURCE:在源文件中有效,表示注解的信息会被编译器抛弃，不会留在class文件中，注解的信息只会留在源文件中；
　　　　2.CLASS:在class文件中有效m,表示注解的信息被保留在class文件(字节码文件)中当程序编译时，但不会被虚拟机读取在运行的时候；
　　　　3.RUNTIME:在运行时有效,表示注解的信息被保留在class文件(字节码文件)中当程序编译时，会被虚拟机保留在运行时;

@Documented:

@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。



```css
 @Inherited：
```

@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。

注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。

当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。

自定义注解：

使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。

定义注解格式：
　　public @interface 注解名 {定义体}

注解参数的可支持数据类型：

1.所有基本数据类型（**int,float,boolean,byte,double,char,long,short**)
　　　　**2.String类型**
　　　　**3.Class类型**
　　　　**4.enum类型**
　　　　**5.Annotation类型**
　　　　6.以上所有类型的数组

Annotation类型里面的参数该怎么设定:
　　第一,只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型；　 　
　　第二,参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为String;　　
　　第三,如果只有一个参数成员,最好把参数名称设为"value",后加小括号.例:下面的例子FruitName注解就只有一个参数成员。

@Target({ ElementType.TYPE })
@Retention(RetentionPolicy.RUNTIME)
public @interface Inject {

public boolean isFull() default false;



# 5.jquery基础

##  1.jquery选择器

​     1.基本选择器：**id选择器  #id** --> 匹配指定id名称

​                               **元素选择器**  --> 匹配指定标签名

​                               **类型选择器  .class** --> 匹配class属性的标签

​                               **通配符选择器** --> 匹配所有的选择器 

​                              **组合选择器**  selector1,selector2,selectorN  --> 即可匹配多个

​        2.层级选择器：**ancestor descendant** --> 在指定父元素下匹配所有的后代元素

​                                   **parent > child** --> 在指定父元素下匹配所有的子元素

​                                   prev + next**  -->  匹配所有紧挨着在 prev 元素后的 next 元素

​         3.伪类选择器   **:first**  -->  获取第一个元素

​                                   **:last**   -->  获取最后一个元素

​                                  **:not(selector)**  -->  用于筛选的选择器(即取反)

​                                  **:even**   -->  匹配所有索引值为偶数的元素，从 0 开始计数

​                                 **:odd**  -->  匹配所有索引值为奇数的元素，从 0 开始计数

​           4.属性选择器    [属性名]**  -->  匹配包含给定属性的元素

​                                     **[属性名=属性值]**  -->  匹配给定的属性是某个特定值的元素

​                                    **[属性名],[属性名]**  -->  可匹配多个

​                                 **[属性选择器][属性选择器][属性选择器]**  -->  复合属性选择器，需要同时满足多个



##  2  ajax参数：

​           jquery中的ajax方法参数

  url:

要求为String类型的参数，（默认为当前页地址）发送请求的地址。

type:

要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。

timeout:

要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。

async:

要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。

cache:

要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。

data:

要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看　　processData选项。对象必须为key/value格式，例如：

```
{
    foo1:"bar1",
    foo2:"bar2"
}

=>&foo1=bar1&foo2=bar2。

//如果是数组，JQuery将自动为不同值对应同一个名称。例如
 
{
    foo:["bar1","bar2"]
} 

=> &foo=bar1&foo=bar2。
```

dataType:

要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：

- xml：返回XML文档，可用JQuery处理。
- html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。
- script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。
- json：返回JSON数据。
- jsonp：JSONP格式。使用SONP形式调用函数时，
  例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。
- text：返回纯文本字符串。

beforeSend：

要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。

```
function(XMLHttpRequest){    
    this;   //调用本次ajax请求时传递的options参数    
}
```

complete：

要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。

```
function(XMLHttpRequest, textStatus){
    this;    //调用本次ajax请求时传递的options参数
}
```

success：

要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。
(1)由服务器返回，并根据dataType参数进行处理后的数据。
(2)描述状态的字符串。

```
function(data, textStatus){
    //data可能是xmlDoc、jsonObj、html、text等等
    this;  //调用本次ajax请求时传递的options参数
}
```

error:

要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下：

```
function(XMLHttpRequest, textStatus, errorThrown){
  //通常情况下textStatus和errorThrown只有其中一个包含信息
  this;   //调用本次ajax请求时传递的options参数
}
```

contentType：

要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为 "application/x-www-form-urlencoded" 。该默认值适合大多数应用场合。

dataFilter：

要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。

```js
function(data, type){
    //返回处理后的数据
    return data;
}
```

global：

要求为Boolean类型的参数，默认为true。表示是否触发全局ajax事件。设置为false将不会触发全局ajax事件，ajaxStart或ajaxStop可用于控制各种ajax事件。

ifModified：

要求为Boolean类型的参数，默认为false。仅在服务器数据改变时获取新数据。服务器数据改变判断的依据是Last-Modified头信息。默认值是false，即忽略头信息。

jsonp：

要求为String类型的参数，在一个jsonp请求中重写回调函数的名字。该值用来替代在"callback=?"这种GET或POST请求中URL参数里的"callback"部分，例如{jsonp:'onJsonPLoad'}会导致将"onJsonPLoad=?"传给服务器。

username：

要求为String类型的参数，用于响应HTTP访问认证请求的用户名。

password：

要求为String类型的参数，用于响应HTTP访问认证请求的密码。

processData：

要求为Boolean类型的参数，默认为true。默认情况下，发送的数据将被转换为对象（从技术角度来讲并非字符串）以配合默认内容类型"application/x-www-form-urlencoded"。如果要发送DOM树信息或者其他不希望转换的信息，请设置为false。

scriptCharset：

要求为String类型的参数，只有当请求时dataType为"jsonp"或者"script"，并且type是GET时才会用于强制修改字符集(charset)。通常在本地和远程的内容编码不同时使用。

```
$(function(){
    $('#send').click(function(){
        $.ajax({
         type: "GET",
         url: "test.json",
         data: {username:$("#username").val(), content:$("#content").val()},
         dataType: "json",
         success: function(data){
                    console.log(data);
                  }
        });
    });
});
```

##      3.css选择器：



1.通配选择器

> CSS2引入了一种新的简单选择器，称为通配选择器（universal selector），显示为一个星号（*）。这个选择器可以与任何元素匹配，就像是一个通配符

```css
* {color: red;}
```

2.类选择器

> 要应用样式而不考虑具体涉及的元素，最常用的方法就是使用类选择器。在使用类选择器之前，需要修改具体的文档标记，以便选择器正常工作
>
> 为了将一个类选择器的样式与元素关联，必须将 class 属性指定为一个适当的值

```css
*.warning {font-weight: bold;}
p.warning {font-weight: bold;}
.warning {font-weight: bold;}
```

元素选择器

```css
 p {font-weight: bold;}
 div {font-style: italic;}
div {background: silver;}
```

3.ID 选择器

> ID 选择器前面有一个 # 号
>
> ID 选择器不引用 class 属性的值
>
> 在一个 HTML 文档中，ID 选择器会使用一次，且仅一次

```
*#first-para {font-weight: bold;}
#first-para {font-weight: bold;}
```

4.属性选择器

> 在某些标记语言中，不能使用类和 ID 选择器。为了解决这个问题，CSS2引入了属性选择器（attribute selector），它可以根据元素的属性及属性值来选择元素

简单属性选择

> 如果希望选择某个属性的元素，而不讨论该属性的值是什么，可以使用一个简单属性选择器

```
<h1 class="hoopla">Hello</h1>
<h1 class="severe">Serenity</h1>
<h1 class="fancy">Fooling</h1>
h1[class] {color: silver;}
img[alt] {border: 3px solid red;} /*对所有带有 alt 属性的图像应用样式*/
*[title] {font-weight: bold;} /*包含标题(title)信息的所有元素变为粗体显示*/
```

根据具体属性值选择

> 除了选择有某些属性的元素，还可以进一步缩小选择范围，只选择有特定属性值的元素

```
/*将指向 Web 服务器上某个特定超链接变成粗体*/
a[href="https://blog.maplemark.cn"] {font-weight: bold;}
<planet>Venus</planet>
<planet moons="1">Earth</planet>
<planet moons="2">Mars</planet>
/*将第二个元素文本变成粗体*/
planet[moons="1"] {
    font-weight: bold;
}
```

根据部分属性值选择

> 如果属性能接受词列表（词之间用空格分隔），可以根据其中的任意一个词进行选择

```
img[title~="Figure"] {border: 1px solid gray;}
```

- 子串匹配属性选择器

| 类型         | 描述                                     |
| ------------ | ---------------------------------------- |
| [foo^="bar"] | 选择 foo 属性值以"bar"开头的所有元素     |
| [foo$="bar"] | 选择 foo 属性值以"bar"结尾的所有元素     |
| [foo*="bar"] | 选择 foo 属性值中包含子串"bar"的所有元素 |

特定属性选择类型

```
<h1 lang="en">Hello!</h1>
<p lang="en-us">Greetings!</p>
<div lang="en-au">G'day!</div>
<p lang="fr">Bonjour!</p>
<h4 lang="cy-en">Jrooana!</h4>
*[lang|="en"] {color: white;}
```

> 这种属性选择器最常见的用途是匹配语言值

5.后代选择器

![文档树结构](https://segmentfault.com/img/bVbqO24?w=800&h=450)

> 通过文档树结构，可以很形象的理解什么是后代选择器（descendant selector），也称为包含选择器/上下文选择器。定义后代选择器就是来创建一些规则，它们仅在某些结构中起作用，而在另外一些结构中不起作用

```
<div class="row"><p>文字一</p></div>
<div class="row"><div><p>文字一后代</p></div></div>
<div class="row">文字二</div>
<p>文字三</p>
.row p{color: red;}
```

选择子元素

> 在某些情况下，可能并不想选择一个任意的后代元素；而是希望缩小范围，只选择另一个元素的子元素

```
.row > p{color: red;}
```

选择相邻兄弟元素

```
<ol>
    <li>List item 1</li>
    <li>List item 1</li>
    <li>List item 1</li>
    <li>List item 1</li>
</ol>
<ul>
    <li>A list item</li>
    <li>Another list item</li>
    <li>Yet Another list item</li>
    <li>Lat list item</li>
</ul>
ol + ul {font-weight: bold;} /*将命中 ul*/
```

> ul 必须紧跟在 ol 后面

6.伪类选择器

> 锚类型称为伪类

链接伪类

CSS2.1定义了两个只应用于超链接的伪类

| 伪类名   | 描述                                       |
| -------- | ------------------------------------------ |
| :link    | 指示作为超链接并指向一个未访问地址的所有锚 |
| :visited | 指示作为已访问超链接的所有锚               |

```
a {color: black;}
a:link {color: bule;}
a:visited {color: red;}
```

动态伪类

> CSS2.1定义了3个动态伪类，它们可以根据用户行为改变文档的外观

| 伪类名  | 描述                         |
| ------- | ---------------------------- |
| :focus  | 指示当前拥有输入焦点的元素   |
| :hover  | 指示鼠标指针停留在哪个元素上 |
| :active | 指示被用户输入激活的元素     |

> 伪类顺序：link-visited-focus-hover-active

选择第一个子元素

> 可以使用静态伪类:first-child 来选择元素的第一个子元素

```
p:first-child {font-weight: bold;}
```

7.伪元素选择器

> 就像伪类为锚指定幻像类一样，伪元素能够在文档中插入假象的元素，从而得到某种效果。CSS2.1中定义了4个伪元素：设置首字母样式、设置第一行样式、设置之前和之后元素的样式

设置首字母样式

```css
p:first-letter {color: red;}
```

设置第一行样式

```css
p:first-line {color: purple;}
```

:first-letter 和 :first-line 的限制

> 在 CSS2 中，:first-letter 和:first-line 伪元素只能应用于标记或段落之类的块级元素，而不能应用于超链接等的行内元素

设置之前和之后元素的样式

```css
p:before {color: black;}
p:after {color: red;}
```

​                                 

jquery选择器 1.基本选择器  1.通配符选择器 2.id选择器 3.元素选择器 4.类选择.器

​                         2.层次选择器   div p

​                          3.伪类选择器 （frist last none ）

​                          4.属性选择器

ajax的参数：1.url 2.Type(post/get) 3.data 4.contextType 5 success 6.error 7beforeSend 8complement 9dataType 10.synce 11.cache 12.timeout

 css选择器   1.类选择器

​                       2.通配符选择器

​                       3.属性选择器

​                       4.id选择器

​                       5.子类选择器

​                       6伪类选择器

​                      7.伪元素选择器



​           BeanFactory

## 4.编写jquery插件

​    如今做web开发，jquery 几乎是必不可少的，就连vs神器在2010版本开始将Jquery 及ui 内置web项目里了。至于使用jquery好处这里就不再赘述了，用过的都知道。今天我们来讨论下jquery的插件机制，jquery有着成千上万的第 三方插件，有时我们写好了一个独立的功能，也想将其与jquery结合起来，可以用jquery链式调用，这就要扩展jquery，写成插件形式了，如下 面就是一个简单扩展Jquery对象的demo：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```js
//sample:扩展jquery对象的方法，bold()用于加粗字体。
(function ($) {
  $.fn.extend({
    "bold": function () {
      ///<summary>
      /// 加粗字体
      ///</summary>
      return this.css({ fontWeight: "bold" });
    }
  });
})(jQuery);
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

调用方式：

这是一个非常简单的扩展。接下来我们一步步来解析上面的代码。

**一、jquery的插件机制**

为了方便用户创建插件，jquery提供了jQuery.extend()和jQuery.fn.extend()方法。

1. jQuery.extend() 方法有一个重载。

jQuery.extend(object) ,一个参数的用于扩展jQuery类本身，**也就是用来在jQuery类/命名空间上增加新函数，或者叫静态方法**，例如jQuery内置的 ajax方法都是用jQuery.ajax()这样调用的，有点像 "类名.方法名" 静态方法的调用方式。下面我们也来写个jQuery.extend(object)的例子：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```js
//扩展jQuery对象本身
jQuery.extend({
  "minValue": function (a, b) {
    ///<summary>
    /// 比较两个值，返回最小值
    ///</summary>
    return a < b ? a : b;
  },
  "maxValue": function (a, b) {
    ///<summary>
    /// 比较两个值，返回最大值
    ///</summary>
    return a > b ? a : b;
  }
});
//调用
var i = 100; j = 101;
var min_v = $.minValue(i, j); // min_v 等于 100
var max_v = $.maxValue(i, j); // max_v 等于 101
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

**重载版本：**

jQuery.extend([deep], target, object1, [objectN])

用一个或多个其他对象来扩展一个对象，返回被扩展的对象。
如果不指定target，则给jQuery命名空间本身进行扩展。这有助于插件作者为jQuery增加新方法。
如果第一个参数设置为true，则jQuery返回一个深层次的副本，递归地复制找到的任何对象。否则的话，副本会与原对象共享结构。
未定义的属性将不会被复制，然而从对象的原型继承的属性将会被复制。

**参数：**

  deep:    可选。如果设为true，则递归合并。
  target:   待修改对象。
  object1:  待合并到第一个对象的对象。
  objectN:  可选。待合并到第一个对象的对象。

**示例1：**

合并 settings 和 options，修改并返回 settings。

```js
var settings = { validate: false, limit: 5, name: "foo" };
var options = { validate: true, name: "bar" };
jQuery.extend(settings, options);
```

结果：

```js
settings == { validate: true, limit: 5, name: "bar" }
```

**示例2：**

合并 defaults 和 options, 不修改 defaults。

```js
var empty = {};
var defaults = { validate: false, limit: 5, name: "foo" };
var options = { validate: true, name: "bar" };
var settings = jQuery.extend(empty, defaults, options);
```

结果：

```js
settings == { validate: true, limit: 5, name: "bar" }
empty == { validate: true, limit: 5, name: "bar" }
```

<u>这个重载的方法，我们一般用来在编写插件时用自定义插件参数去覆盖插件的默认参数</u>。

<u>jQuery.fn.extend(object)扩展 jQuery 元素集来提供新的方法（通常用来制作插件</u>）。

首先我们来看fn 是什么东西呢。查看jQuery代码，就不难发现。

```js
jQuery.fn = jQuery.prototype = {
  init: function( selector, context ) {.....};
};
```

原来 jQuery.fn = jQuery.prototype，也就是jQuery对象的原型。那jQuery.fn.extend()方法就是扩展jQuery对象的原型方法。我 们知道扩展原型上的方法，就相当于为对象添加"成员方法"，类的"成员方法"要类的对象才能调用，所以使用 jQuery.fn.extend(object)扩展的方法， jQuery类的实例可以使用这个"成员函数"。jQuery.fn.extend(object)和jQuery.extend(object)方法一 定要区分开来。

**二、自执行的匿名函数/闭包**

1. 什么是自执行的匿名函数?

它是指形如这样的函数:

```js
(function {code})();
```

2. 疑问 为什么(function {code})();可以被执行, 而function {code}();却会报错?

3. 分析

(1). 首先, 要清楚两者的区别:

**(function {code})是表达式, function { code}是函数声明.**

(2). 其次, js"预编译"的特点:

js在"预编译"阶段, 会解释函数声明, 但却会忽略表式.

(3). 当js执行到function() {code}();时, 由于function() {code}在"预编译"阶段已经被解释过, js会跳过function(){code}, 试图去执行();, 故会报错;
当js执行到(function {code})();时, 由于(function {code})是表达式, js会去对它求解得到返回值, 由于返回值是一 个函数, 故而遇到();时, 便会被执行.
另外， 函数转换为表达式的方法并不一定要靠分组操作符()，我们还可以用void操作符，~操作符，!操作符……

例如：

bootstrap 框架中的插件写法：

```js
!function($){
//do something;
}(jQuery);
```

和

```js
(function($){
//do something;
})(jQuery);
```

是一回事。

匿名函数最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用。

例如：

```js
var a=1;
(function()(){
  var a=100;
})();
alert(a); //弹出 1
```

**三、一步一步封装JQuery插件**

接下来我们一起来写个高亮的jqury插件

1.定一个闭包区域，防止插件"污染"

```js
//闭包限定命名空间
(function ($) {
})(window.jQuery);
```

2.jQuery.fn.extend(object)扩展jquery 方法，制作插件

```js
//闭包限定命名空间
(function ($) {
  $.fn.extend({
    "highLight":function(options){
      //do something
    }
  });
})(window.jQuery);
```

3.给插件默认参数，实现 插件的功能

```js
//闭包限定命名空间
(function ($) {
  $.fn.extend({
    "highLight": function (options) {
      var opts = $.extend({}, defaluts, options); //使用jQuery.extend 覆盖插件默认参数
      this.each(function () { //这里的this 就是 jQuery对象
        //遍历所有的要高亮的dom,当调用 highLight()插件的是一个集合的时候。
        var $this = $(this); //获取当前dom 的 jQuery对象，这里的this是当前循环的dom
        //根据参数来设置 dom的样式
        $this.css({
          backgroundColor: opts.background,
          color: opts.foreground
        });
      });
    }
  });
  //默认参数
  var defaluts = {
    foreground: 'red',
    background: 'yellow'
  };
})(window.jQuery);
```

到这一步，高亮插件基本功能已经具备了。调用代码如下：

```js
$(function () {
  $("p").highLight(); //调用自定义 高亮插件
});
```

这里只能 直接调用，不能链式调用。我们知道jQuey是可以链式调用的，就是可以在一个jQuery对象上调用多个方法，如：

```js
$(``'#id'``).css({marginTop:``'100px'``}).addAttr(``"title"``,``"测试"``);
```

但是我们上面的插件，就不能这样链式调用了。比如：

```js
$("p").highLight().css({marginTop:'100px'});
```

将会报找不到css方法，原因在与我的自定义插件在完成功能后，没有将 jQuery对象给返回出来。接下来，return jQuery对象，让我们的插件也支持链式调用。（其实很简单，就是执行完我们插件代码的时候将jQuery对像return 出来，和上面的代码没啥区别）

```js
//闭包限定命名空间
(function ($) {
  $.fn.extend({
    "highLight": function (options) {
      var opts = $.extend({}, defaluts, options); //使用jQuery.extend 覆盖插件默认参数
      return this.each(function () { //这里的this 就是 jQuery对象。这里return 为了支持链式调用
        //遍历所有的要高亮的dom,当调用 highLight()插件的是一个集合的时候。
        var $this = $(this); //获取当前dom 的 jQuery对象，这里的this是当前循环的dom
        //根据参数来设置 dom的样式
        $this.css({
          backgroundColor: opts.background,
          color: opts.foreground
        });
      });
    }
  });
  //默认参数
  var defaluts = {
    foreground: 'red',
    background: 'yellow'
  };
})(window.jQuery);
```

4.暴露公共方法 给别人来扩展你的插件（如果有需求的话）

比如的高亮插件有一个format方法来格式话高亮文本，则我们可将它写成公共的，暴露给插件使用者，不同的使用着根据自己的需求来重写该format方法，从而是高亮文本可以呈现不同的格式。

```js
//公共的格式化 方法. 默认是加粗，用户可以通过覆盖该方法达到不同的格式化效果。
$.fn.highLight.format = function (str) {
  return "<strong>" + str + "</strong>";
}
```

5.插件私有方法

有些时候，我们的插件需要一些私有方法，不能被外界访问。例如 我们插件里面需要有个方法 来检测用户调用插件时传入的参数是否符合规范。

6.其他的一些设置，如：为你的插件加入元数据插件的支持将使其变得更强大。

完整的高亮插件代码如下：

```js
//闭包限定命名空间
(function ($) {
  $.fn.extend({
    "highLight": function (options) {
      //检测用户传进来的参数是否合法
      if (!isValid(options))
        return this;
      var opts = $.extend({}, defaluts, options); //使用jQuery.extend 覆盖插件默认参数
      return this.each(function () { //这里的this 就是 jQuery对象。这里return 为了支持链式调用
        //遍历所有的要高亮的dom,当调用 highLight()插件的是一个集合的时候。
        var $this = $(this); //获取当前dom 的 jQuery对象，这里的this是当前循环的dom
        //根据参数来设置 dom的样式
        $this.css({
          backgroundColor: opts.background,
          color: opts.foreground
        });
        //格式化高亮文本
        var markup = $this.html();
        markup = $.fn.highLight.format(markup);
        $this.html(markup);
      });
    }
  });
  //默认参数
  var defaluts = {
    foreground: 'red',
    background: 'yellow'
  };
  //公共的格式化 方法. 默认是加粗，用户可以通过覆盖该方法达到不同的格式化效果。
  $.fn.highLight.format = function (str) {
    return "<strong>" + str + "</strong>";
  }
  //私有方法，检测参数是否合法
  function isValid(options) {
    return !options || (options && typeof options === "object") ? true : false;
  }
})(window.jQuery);
```

调用：

```js
//调用
//调用者覆盖 插件暴露的共公方法
$.fn.highLight.format = function (txt) {
  return "<em>" + txt + "</em>"
}
$(function () {
  $("p").highLight({ foreground: 'orange', background: '#ccc' }); //调用自定义 高亮插件
});
```



## 6.Redis基础：

#####    （redis修改就是先删除后增加）

# [Redis的五种数据类型及方法](https://www.cnblogs.com/dijia478/p/8058775.html)

## **字符串string**：

字符串类型是Redis中最为基础的数据存储类型，是一个由字节组成的序列，他在Redis中是二进制安全的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据货Json对象描述信息等，是标准的key-value，一般来存字符串，整数和浮点数。Value最多可以容纳的数据长度为512MB
应用场景：很常见的场景用于统计网站访问数量，当前在线人数等。incr命令(++操作)

![img](https://images2017.cnblogs.com/blog/1267939/201712/1267939-20171218173355068-1009075048.png)

 

## **列表list**：

Redis的列表允许用户从序列的两端推入或者弹出元素，列表由多个字符串值组成的有序可重复的序列，是链表结构，所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的。List中可以包含的最大元素数量是4294967295。
应用场景：1.最新消息排行榜。2.消息队列，以完成多程序之间的消息交换。可以用push操作将任务存在list中（生产者），然后线程在用pop操作将任务取出进行执行。（消费者）

![img](https://images2017.cnblogs.com/blog/1267939/201712/1267939-20171218173319896-1986145136.png)

 

## **散列hash**：

Redis中的散列可以看成具有String key和String value的map容器，可以将多个key-value存储到一个key中。每一个Hash可以存储4294967295个键值对。
应用场景：例如存储、读取、修改用户属性（name，age，pwd等）

![img](https://images2017.cnblogs.com/blog/1267939/201712/1267939-20171218173425803-1568128972.png)

 

## **集合set**：

Redis的集合是无序不可重复的，和列表一样，在执行插入和删除和判断是否存在某元素时，效率是很高的。集合最大的优势在于可以进行交集并集差集操作。Set可包含的最大元素数量是4294967295。
应用场景：1.利用交集求共同好友。2.利用唯一性，可以统计访问网站的所有独立IP。3.好友推荐的时候根据tag求交集，大于某个threshold（临界值的）就可以推荐。

![img](https://images2017.cnblogs.com/blog/1267939/201712/1267939-20171218173450459-219862735.png)

 

## **有序集合sorted set**：

和set很像，都是字符串的集合，都不允许重复的成员出现在一个set中。他们之间差别在于有序集合中每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。尽管有序集合中的成员必须是卫衣的，但是分数(score)却可以重复。
应用场景：可以用于一个大型在线游戏的积分排行榜，每当玩家的分数发生变化时，可以执行zadd更新玩家分数(score)，此后在通过zrange获取几分top ten的用户信息。

![img](https://images2017.cnblogs.com/blog/1267939/201712/1267939-20171218173530318-1825724249.png)

##  

## 最后，还有个对key的通用操作，所有的数据类型都可以使用的

![img](https://images2017.cnblogs.com/blog/1267939/201712/1267939-20171218173804350-2060665680.png)

## 7.Disruptor框架





## 8.rpc

​    1. 基本的RPC模型

主要介绍RPC是什么，基本的RPC代码，RPC与REST的区别，gRPC的使用

## 1.1 基本概念

- RPC（Remote Procedure Call）**远程过程调用**，简单的理解是一个节点请求另一个节点提供的服务
- 本地过程调用：如果需要将本地student对象的age+1，可以实现一个addAge()方法，将student对象传入，对年龄进行更新之后返回即可，本地方法调用的函数体通过函数指针来指定。
- 远程过程调用：上述操作的过程中，如果addAge()这个方法在服务端，执行函数的函数体在远程机器上，如何告诉机器需要调用这个方法呢？

1. 首先客户端需要告诉服务器，需要调用的函数，**这里函数和进程ID存在一个映射，客户端远程调用时，需要查一下函数，找到对应的ID，然后执行函数的代码**。
2. 客户端需要把本地参数传给远程函数，本地调用的过程中，直接压栈即可，但是在远程调用过程中不再同一个内存里，无法直接传递函数的参数，因此需要客户端把**参数转换成字节流**，**传给服务端**，然后服务端将字节流转换成自身能读取的格式，是**一个序列化和反序列化的过程**。
    3.数据准备好了之后，如何进行传输？网络传输层需要把调用的ID和序列化后的参数传给服务端，然后把计算好的结果序列化传给客户端，因此TCP层即可完成上述过程，gRPC中采用的是HTTP2协议。
    总结一下上述过程：



```csharp
// Client端 
//    Student student = Call(ServerAddr, addAge, student)
1. 将这个调用映射为Call ID。
2. 将Call ID，student（params）序列化，以二进制形式打包
3. 把2中得到的数据包发送给ServerAddr，这需要使用网络传输层
4. 等待服务器返回结果
5. 如果服务器调用成功，那么就将结果反序列化，并赋给student，年龄更新

// Server端
1. 在本地维护一个Call ID到函数指针的映射call_id_map，可以用Map<String, Method> callIdMap
2. 等待服务端请求
3. 得到一个请求后，将其数据包反序列化，得到Call ID
4. 通过在callIdMap中查找，得到相应的函数指针
5. 将student（params）反序列化后，在本地调用addAge()函数，得到结果
6. 将student结果序列化后通过网络返回给Client
```

![img](https:////upload-images.jianshu.io/upload_images/7632302-ca0ba3118f4ef4fb.png?imageMogr2/auto-orient/strip|imageView2/2/w/560/format/webp)

- 在微服务的设计中，一个服务A如果访问另一个Module下的服务B，可以采用**HTTP REST**传输数据，并在两个服务之间进行序列化和反序列化操作，服务B把执行结果返回过来。

  ![img](https:////upload-images.jianshu.io/upload_images/7632302-19ad38cdd9a4b3ec.png?imageMogr2/auto-orient/strip|imageView2/2/w/723/format/webp)

- 由于HTTP在应用层中完成，整个通信的代价较高，远程过程调用中直接基于**TCP进行远程调用**，数据传输在传输层TCP层完成，更适合对效率要求比较高的场景，**RPC主要依赖于客户端和服务端之间建立Socket链接**进行，底层实现比REST更复杂。

## 1.2 rpc demo

![img](https:////upload-images.jianshu.io/upload_images/7632302-85786c3ba6daba9a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

系统类图

![img](https:////upload-images.jianshu.io/upload_images/7632302-ecb01c0f93876a5d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

系统调用过程

客户端：



```java
public class RPCClient<T> {
    public static <T> T getRemoteProxyObj(final Class<?> serviceInterface, final InetSocketAddress addr) {
        // 1.将本地的接口调用转换成JDK的动态代理，在动态代理中实现接口的远程调用
        return (T) Proxy.newProxyInstance(serviceInterface.getClassLoader(), new Class<?>[]{serviceInterface},
                new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        Socket socket = null;
                        ObjectOutputStream output = null;
                        ObjectInputStream input = null;
                        try{
                            // 2.创建Socket客户端，根据指定地址连接远程服务提供者
                            socket = new Socket();
                            socket.connect(addr);

                            // 3.将远程服务调用所需的接口类、方法名、参数列表等编码后发送给服务提供者
                            output = new ObjectOutputStream(socket.getOutputStream());
                            output.writeUTF(serviceInterface.getName());
                            output.writeUTF(method.getName());
                            output.writeObject(method.getParameterTypes());
                            output.writeObject(args);

                            // 4.同步阻塞等待服务器返回应答，获取应答后返回
                            input = new ObjectInputStream(socket.getInputStream());
                            return input.readObject();
                        }finally {
                            if (socket != null){
                                socket.close();
                            }
                            if (output != null){
                                output.close();
                            }
                            if (input != null){
                                input.close();
                            }
                        }
                    }
                });
    }
}
```

服务端：



```java
public class ServiceCenter implements Server {

    private static ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());

    private static final HashMap<String, Class> serviceRegistry = new HashMap<String, Class>();

    private static boolean isRunning = false;

    private static int port;


    public ServiceCenter(int port){
        ServiceCenter.port = port;
    }


    @Override
    public void start() throws IOException {
        ServerSocket server = new ServerSocket();
        server.bind(new InetSocketAddress(port));
        System.out.println("Server Start .....");
        try{
            while(true){
                executor.execute(new ServiceTask(server.accept()));
            }
        }finally {
            server.close();
        }
    }

    @Override
    public void register(Class serviceInterface, Class impl) {
        serviceRegistry.put(serviceInterface.getName(), impl);
    }

    @Override
    public boolean isRunning() {
        return isRunning;
    }

    @Override
    public int getPort() {
        return port;
    }

    @Override
    public void stop() {
        isRunning = false;
        executor.shutdown();
    }
   private static class ServiceTask implements Runnable {
        Socket client = null;

        public ServiceTask(Socket client) {
            this.client = client;
        }

        @Override
        public void run() {
            ObjectInputStream input = null;
            ObjectOutputStream output = null;
            try{
                input = new ObjectInputStream(client.getInputStream());
                String serviceName = input.readUTF();
                String methodName = input.readUTF();
                Class<?>[] parameterTypes = (Class<?>[]) input.readObject();
                Object[] arguments = (Object[]) input.readObject();
                Class serviceClass = serviceRegistry.get(serviceName);
                if(serviceClass == null){
                    throw new ClassNotFoundException(serviceName + "not found!");
                }
                Method method = serviceClass.getMethod(methodName, parameterTypes);
                Object result = method.invoke(serviceClass.newInstance(), arguments);

                output = new ObjectOutputStream(client.getOutputStream());
                output.writeObject(result);
            }catch (Exception e){
                e.printStackTrace();
            }finally {
                if(output!=null){
                    try{
                        output.close();
                    }catch (IOException e){
                        e.printStackTrace();
                    }
                }
                if (input != null) {
                    try {
                        input.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
                if (client != null) {
                    try {
                        client.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}
```



```java
public class ServiceProducerImpl implements ServiceProducer{
    @Override
    public String sendData(String data) {
        return "I am service producer!!!, the data is "+ data;
    }
}
```



```java
public class RPCTest {
    public static void main(String[] args) throws IOException {
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Server serviceServer = new ServiceCenter(8088);
                    serviceServer.register(ServiceProducer.class, ServiceProducerImpl.class);
                    serviceServer.start();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }).start();
        ServiceProducer service = RPCClient.getRemoteProxyObj(ServiceProducer.class, new InetSocketAddress("localhost", 8088));
        System.out.println(service.sendData("test"));
    }
}
```

## 1.3 完整源码

[RPCdemo](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fguangxush%2Fwheel%2Ftree%2Fmaster%2FRPC%2Fsrc)

## 1.4 分析

这里客户端只需要知道Server端的接口ServiceProducer即可，服务端在执行的时候，会根据具体实例调用实际的方法ServiceProducerImpl，符合面向对象过程中父类引用指向子类对象。

# 2. gRPC的使用

## 2.1. gRPC与REST

- REST通常以业务为导向，将业务对象上执行的操作映射到HTTP动词，格式非常简单，可以使用浏览器进行扩展和传输，通过JSON数据完成客户端和服务端之间的消息通信，直接支持请求/响应方式的通信。不需要中间的代理，简化了系统的架构，不同系统之间只需要对JSON进行解析和序列化即可完成数据的传递。

- 但是REST也存在一些弊端，比如只支持请求/响应这种单一的通信方式，对象和字符串之间的序列化操作也会影响消息传递速度，客户端需要通过服务发现的方式，知道服务实例的位置，在单个请求获取多个资源时存在着挑战，而且有时候很难将所有的动作都映射到HTTP动词。

- 正是因为REST面临一些问题，因此可以采用gRPC作为一种替代方案，gRPC 是一种基于二进制流的消息协议，可以采用基于Protocol Buffer的IDL定义grpc API,这是Google公司用于序列化结构化数据提供的一套语言中立的序列化机制，客户端和服务端使用HTTP/2以Protocol Buffer格式交换二进制消息。

- gRPC的优势是，设计复杂更新操作的API非常简单，具有高效紧凑的进程通信机制，在交换大量消息时效率高，远程过程调用和消息传递时可以采用双向的流式消息方式，同时客户端和服务端支持多种语言编写，互操作性强；不过gRPC的缺点是不方便与JavaScript集成，某些防火墙不支持该协议。

- 注册中心：当项目中有很多服务时，可以把所有的服务在启动的时候注册到一个注册中心里面，用于维护服务和服务器之间的列表，当注册中心接收到客户端请求时，去找到该服务是否远程可以调用，如果可以调用需要提供服务地址返回给客户端，客户端根据返回的地址和端口，去调用远程服务端的方法，执行完成之后将结果返回给客户端。这样在服务端加新功能的时候，客户端不需要直接感知服务端的方法，服务端将更新之后的结果在注册中心注册即可，而且当修改了服务端某些方法的时候，或者服务降级服务多机部署想实现负载均衡的时候，我们只需要更新注册中心的服务群即可。

  ![img](https:////upload-images.jianshu.io/upload_images/7632302-0b09dd85b8baa318.png?imageMogr2/auto-orient/strip|imageView2/2/w/790/format/webp)

  RPC调用过程

## 2.2. gRPC与Spring Boot

这里使用SpringBoot+gRPC的形式实现RPC调用过程
 项目结构分为三部分：client、grpc、server



![img](https:////upload-images.jianshu.io/upload_images/7632302-1b5c5463c97005db.png?imageMogr2/auto-orient/strip|imageView2/2/w/417/format/webp)

项目结构

### 2.2.2 grpc

![img](https:////upload-images.jianshu.io/upload_images/7632302-d9202738c49197c0.png?imageMogr2/auto-orient/strip|imageView2/2/w/364/format/webp)



pom.xml中引入依赖：



```xml
<dependency>
      <groupId>io.grpc</groupId>
      <artifactId>grpc-all</artifactId>
       <version>1.12.0</version>
 </dependency>
```

引入bulid



```xml
<build>
        <extensions>
            <extension>
                <groupId>kr.motd.maven</groupId>
                <artifactId>os-maven-plugin</artifactId>
                <version>1.4.1.Final</version>
            </extension>
        </extensions>
        <plugins>
            <plugin>
                <groupId>org.xolstice.maven.plugins</groupId>
                <artifactId>protobuf-maven-plugin</artifactId>
                <version>0.5.0</version>
                <configuration>
                    <pluginId>grpc-java</pluginId>
                    <protocArtifact>com.google.protobuf:protoc:3.0.2:exe:${os.detected.classifier}</protocArtifact>
                    <pluginArtifact>io.grpc:protoc-gen-grpc-java:1.2.0:exe:${os.detected.classifier}</pluginArtifact>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>compile</goal>
                            <goal>compile-custom</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
```

创建.proto文件



```cpp
syntax = "proto3";   // 语法版本

// stub选项
option java_package = "com.shgx.grpc.api";
option java_outer_classname = "RPCDateServiceApi";
option java_multiple_files = true;

// 定义包名
package com.shgx.grpc.api;

// 服务接口定义，服务端和客户端都要遵守该接口进行通信
service RPCDateService {
    rpc getDate (RPCDateRequest) returns (RPCDateResponse) {}
}

// 定义消息（请求）
message RPCDateRequest {
    string userName = 1;
}

// 定义消息（响应）
message RPCDateResponse {
    string serverDate = 1;
}
```

mvn complie



![img](https:////upload-images.jianshu.io/upload_images/7632302-3449e9d116fa1989.png?imageMogr2/auto-orient/strip|imageView2/2/w/366/format/webp)

生成代码：



![img](https:////upload-images.jianshu.io/upload_images/7632302-733af0e5deabb037.png?imageMogr2/auto-orient/strip|imageView2/2/w/480/format/webp)

### 2.2.3 client

![img](https:////upload-images.jianshu.io/upload_images/7632302-89faef93bd6386e9.png?imageMogr2/auto-orient/strip|imageView2/2/w/450/format/webp)



根据gRPC中的项目配置在client和server两个Module的pom.xml添加依赖



![img](https:////upload-images.jianshu.io/upload_images/7632302-fd5057f8ab83e88a.png?imageMogr2/auto-orient/strip|imageView2/2/w/769/format/webp)



```xml
        <dependency>
            <groupId>com.shgx</groupId>
            <artifactId>grpc</artifactId>
            <version>0.0.1-SNAPSHOT</version>
            <scope>compile</scope>
        </dependency>
```

编写GRPCClient



```java
public class GRPCClient {
    private static final String host = "localhost";
    private static final int serverPort = 9999;

    public static void main( String[] args ) throws Exception {
        ManagedChannel managedChannel = ManagedChannelBuilder.forAddress( host, serverPort ).usePlaintext().build();
        try {
            RPCDateServiceGrpc.RPCDateServiceBlockingStub rpcDateService = RPCDateServiceGrpc.newBlockingStub( managedChannel );
            RPCDateRequest rpcDateRequest = RPCDateRequest
                    .newBuilder()
                    .setUserName("shgx")
                    .build();
            RPCDateResponse rpcDateResponse = rpcDateService.getDate( rpcDateRequest );
            System.out.println( rpcDateResponse.getServerDate() );
        } finally {
            managedChannel.shutdown();
        }
    }
}
```

### 2.2.4 server

![img](https:////upload-images.jianshu.io/upload_images/7632302-9f60e557c0fbcdb9.png?imageMogr2/auto-orient/strip|imageView2/2/w/285/format/webp)



按照2.2.3 client的方式添加依赖
 创建RPCDateServiceImpl



```java
public class RPCDateServiceImpl extends RPCDateServiceGrpc.RPCDateServiceImplBase{
    @Override
    public void getDate(RPCDateRequest request, StreamObserver<RPCDateResponse> responseObserver) {
        RPCDateResponse rpcDateResponse = null;
        Date now=new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("今天是"+"yyyy年MM月dd日 E kk点mm分");
        String nowTime = simpleDateFormat.format( now );
        try {
            rpcDateResponse = RPCDateResponse
                    .newBuilder()
                    .setServerDate( "Welcome " + request.getUserName()  + ", " + nowTime )
                    .build();
        } catch (Exception e) {
            responseObserver.onError(e);
        } finally {
            responseObserver.onNext( rpcDateResponse );
        }
        responseObserver.onCompleted();
    }
}
```

创建GRPCServer



```java
public class GRPCServer {
   private static final int port = 9999;
   public static void main( String[] args ) throws Exception {
       Server server = ServerBuilder.
               forPort(port)
               .addService( new RPCDateServiceImpl() )
               .build().start();
       System.out.println( "grpc服务端启动成功, 端口=" + port );
       server.awaitTermination();
   }
}
```

## 2.3. 完整源码

[源码参考](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fguangxush%2FSpringBoot_GRPC)

# 3. 参考文章

- [gRPC - Spring Boot 示例](https://www.jianshu.com/p/80f7929199fd)
- [RPC框架解释](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F25536695)
- [什么是RPC](https://www.jianshu.com/p/eb66b0c4113d)



24人点赞



[SpringBoot]()





作者：时光飞旭
链接：https://www.jianshu.com/p/7d6853140e13
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

作者：洪春涛
链接：https://www.zhihu.com/question/25536695/answer/221638079
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



**本地过程调用**

RPC就是要像调用本地的函数一样去调远程函数。在研究RPC前，我们先看看本地调用是怎么调的。假设我们要调用函数Multiply来计算lvalue * rvalue的结果:

```cpp
1 int Multiply(int l, int r) {
2    int y = l * r;
3    return y;
4 }
5 
6 int lvalue = 10;
7 int rvalue = 20;
8 int l_times_r = Multiply(lvalue, rvalue);
```

那么在第8行时，我们实际上执行了以下操作：

1. 将 lvalue 和 rvalue 的值压栈
2. 进入Multiply函数，取出栈中的值10 和 20，将其赋予 l 和 r
3. 执行第2行代码，计算 l * r ，并将结果存在 y
4. 将 y 的值压栈，然后从Multiply返回
5. 第8行，从栈中取出返回值 200 ，并赋值给 l_times_r

以上5步就是执行本地调用的过程。（20190116注：以上步骤只是为了说明原理。事实上编译器经常会做优化，对于参数和返回值少的情况会直接将其存放在寄存器，而不需要压栈弹栈的过程，甚至都不需要调用call，而直接做inline操作。仅就原理来说，这5步是没有问题的。）



**远程过程调用带来的新问题**

在远程调用时，我们需要执行的函数体是在远程的机器上的，也就是说，Multiply是在另一个进程中执行的。这就带来了几个新问题：

1. **Call ID映射**。我们怎么告诉远程机器我们要调用Multiply，而不是Add或者FooBar呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用Multiply，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 <--> Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。
2. **序列化和反序列化**。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。
3. **网络传输**。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。

有了这三个机制，就能实现RPC了，具体过程如下：

```cpp
// Client端 
//    int l_times_r = Call(ServerAddr, Multiply, lvalue, rvalue)
1. 将这个调用映射为Call ID。这里假设用最简单的字符串当Call ID的方法
2. 将Call ID，lvalue和rvalue序列化。可以直接将它们的值以二进制形式打包
3. 把2中得到的数据包发送给ServerAddr，这需要使用网络传输层
4. 等待服务器返回结果
5. 如果服务器调用成功，那么就将结果反序列化，并赋给l_times_r

// Server端
1. 在本地维护一个Call ID到函数指针的映射call_id_map，可以用std::map<std::string, std::function<>>
2. 等待请求
3. 得到一个请求后，将其数据包反序列化，得到Call ID
4. 通过在call_id_map中查找，得到相应的函数指针
5. 将lvalue和rvalue反序列化后，在本地调用Multiply函数，得到结果
6. 将结果序列化后通过网络返回给Client
```

所以要实现一个RPC框架，其实只需要按以上流程实现就基本完成了。

其中：

- Call ID映射可以直接使用函数字符串，也可以使用整数ID。映射表一般就是一个哈希表。
- 序列化反序列化可以自己写，也可以使用Protobuf或者FlatBuffers之类的。
- 网络传输库可以自己写socket，或者用asio，ZeroMQ，Netty之类。

当然，这里面还有一些细节可以填充，比如如何处理网络错误，如何防止攻击，如何做流量控制，等等。但有了以上的架构，这些都可以持续加进去。

最后，有兴趣的可以看我们自己写的一个小而精的RPC库 tinyrpc（[hjk41/tinyrpc](https://link.zhihu.com/?target=https%3A//github.com/hjk41/tinyrpc)），对于理解RPC如何工作很有好处。



为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。

RPC的基本原理：服务端在注册中心 注册------》客户端调用服务端方法----》从注册中心中拿到服务端方法的信息----》客户端将参数/服务端call ID转化成字节流（序列化）-----》服务端反序列化数据-----》根据参数列表级call Id

找到对应方法并执行----》将执行结果序列化传输给客户端-----》客户端反序列化----得到结果

1.怎么知道要调用那个具体的方法  使用 call ID来实现

2.怎么传递参数  客户端将参数序列化-----服务端将参数反序列化

3.怎么建立连接  使用TCP通讯  使用socket作为连接

分布式框架

**一、RPC**

　　RPC（Remote Process Call），即远程服务调用，被广泛地应用在很多企业应用中，是早期主要的服务治理方案，其流程较为简单，客户端consumer携带参数发送RPC请求到服务提供方provider，provider根据参数路由到具体函数，方法，并将执行获得的结果返回，至此一次RPC调用完成。

　　![img](https://images2018.cnblogs.com/blog/1135193/201808/1135193-20180811144350525-497208600.png)

　　随着业务的发展，大数据时代的到来，服务提供方的压力也日益增大，单机应用的处理能力无论在软件，硬件上都受到限制，provider也不可能一直无限扩容，即使扩容，也存在着很多问题，即服务的路由，和Consumer的负载均衡问题。因此，分布式服务架构应运而生，RPC发展到一定阶段思考的变革，成为了分布式服务，云计算的计算机基础。

**二、SOA**

　　由于简单的RPC调用已经不能随着时代发展满足需求，因此复杂的业务逻辑对于分布式应用架构体系的需求愈发强烈，业务希望自己的服务是分布式部署的，请求是分流的，对数据的操作是能读写分离的，同时能屏蔽许多复杂需要自己编写的底层服务，借助已有的公共服务，去快速的构建自己的应用，降低人力开发维护的成本和提高应用交付的效率，基因此，基于分布式服务思想的SOA（Service-Oriented Architecture）成了新的受追捧的架构。常见的SOA服务调用流程图如下：　

　　![img](https://images2018.cnblogs.com/blog/1135193/201808/1135193-20180811150558919-1973931780.png)

**三、业界服务治理方案**

　　业界的互联网巨头公司，都有属于自己的分布式服务框架，如阿里巴巴的Dubbo，HSF，腾讯的Tars，京东的JSF，新浪的Motan，都已经是业界非常成熟的解决方案，其中开源的Dubbo和Motan受到了广大开发者的研究对象。

　　纵观这些服务框架，设计的基本思路都如上图，无非涉及provider发布注册，consumer订阅，调用发起，负载均衡，服务分流和监控等模块，并在此基础上增加了很多玩法，形成了各具特色的分布式服务框架设计，下面就Dubbo，JSF，Motan的设计做下简单的介绍。

　　（1）**Dubbo：下图是Dubbo在服务治理方面的架构设计**

　　**初始化阶段：**部署在Container的Provider启动后向服务中心Registry发布并注册自己的服务，客户端Consumer初始化时即向Registry订阅自己想要的服务，同时Registry对Consumer保持着一个长连接，当订阅的服务新增或减少节点时，会及时通知到客户端更新（此过程是异步进行的，不会影响Consumer的主流程），如此一来，客户端Consumer便有了Provider的所有实时信息，便可以发起服务调用了。

　　**invoke阶段：**客户端Consumer从获得的所有Provider列表中通过负载均衡等策略选出最适合调用的服务提供者Provider并发起同步调用。

　　**Monitor阶段：**Consumer和Provider通过异步的方式向监控中心上报自己的需要被监控的数据。

　　![img](https://images2018.cnblogs.com/blog/1135193/201808/1135193-20180811150804269-4724201.png)

　　（2）**JSF：下图是JSF在服务治理方面的架构设计**

　　***\*初始化阶段：\****Provider启动后向服务注册中心发布注册自己的服务

　　**invoke阶段：**与Dubbo不同的是，JSF的注册中心不向Consumer推送Provider实时数据，而是在发起调用时Consumer向注册中心询问并获得对应的Provider，然后组织匹配JSF协议的报文发起调用。

　　**Monitor阶段：**Provider定期向监控中心发送性能统计数据，同时Provider还会上报事件给事件中心。

　　![img](https://images2018.cnblogs.com/blog/1135193/201808/1135193-20180811151038396-654274162.png)

　　（3）**Motan：Motan是有名的轻量级服务框架，代码质量很高，下图是Motan在服务治理方面的架构设计**

　　Motan的服务治理设计与Dubbo十分的相似，都是Provider发布注册，Consumer订阅与接受推送，之后发起调用。

　　![img](https://images2018.cnblogs.com/blog/1135193/201808/1135193-20180811151108939-1593407841.png)

**四、分布式服务框架主要模块名词释义**

　　无论是那种SOA的架构设计，都离不开几个模块的功能，即Provider，Consumer，Registry，Gateway，负载均衡，服务分流，监控等，通过上述所讲，应该对这些功能模块有了初步的认识，下面就这些名词再作下介绍

　  （1）Provider：服务提供者，无论是业务服务，还是一个系统中公用的SAAS，都属于Provider

　　（2）Consumer：即发起调用的客户端

　　（3）Registry：服务注册中心，是分布式服务系统中的一个重要组成模块，管理Provider的Manager，在实际的运行环境中，服务注册中心Registry被动通知或Consumer主动询问，在Provider有节点宕机或新增节点时，客户端也可实时感知到，从而避免了某个Provider被无限调用或是无限闲置

　　（4）Gateway：网关也是分布式服务框架中不可或缺的部分，每种系统与框架都有自己的一套协议，当异构系统互相调用时，网关的作用即显现出来，Gateway接受各种外部HTTP请求，完成相应的权限校验，报文适配，路由转发到对应的Provider，再将Provider返回的结果传递给异构系统的Consumer，完成异构系统的互相调用

　　（5）负载均衡，服务分流：Consumer从Registry获得具体的Provider列表后，如何选取合适的Provider，取决与一定的负载均衡算法，常见的算法有轮询法，随机法，源地址哈希，加权轮询，加权随机等

　　（6）监控：接收来自Consumer和Provider异步上报的性能监控数据，对有风险的节点发出告警



java基础-->vue.js-->



spring ioc



## Web技术栈

 浏览器（前端）-------服务器（后台）-------数据库(持久层)



1.前端：1.h5(页面（页面布局)

​           2.css(页面样式)   （css选择器 5.3）   ------layui 前端框架

​           3.js(页面动态效果）

​                3.1：jquery（js框架）

​                            ajax():前端于服务端完成异步通信（5.2）

​                            jquery插件扩展---5.4

​           4.模板引擎---将服务器传过来的数据动态渲染到html页面中---beetle

​                               模板引擎（jsp也是一种模板引擎）内置的9大对象----1

2.后端 ：

​                java

​                   1.java基础

​                          1.1 java 集合框架（3.1）

​                          1.2 java 反射（3.2）

​                           1.3 java动态代理（3.3）

​                           1.4 jvm

​                                     1.4.1 jvm内存模型

​                                      1.4.2 类和对象加载过程

​                                      1.4.3 jvm gc

​                                            1.4.3.1：jvm调优

​                                      1.4.4 java多线程实现

​                             2.Web后台：

​                                       1.Spring（框架)：

​                                                    1.spring Ioc 及spring容器启动过程

​                                                     2.spring Aop

​                                                     3.spring事务

​                                                     4.spring MVC（requestMapping注解）

​                                                     5.spring Boot

​                                                     6.spring使用的设计模式

​                                          2.Redis:缓存服务（6）

​                                          3.RPC:服务器之间通讯（7）----分布式框架（dubbo springCloud）

​                                          4.高并发框架   Disruptor

​                                          5.消息队列：RabbitMQ（异步通信、解耦合、流量削峰）

​                                          6.安全问题：Shiro框架（单点登陆/登陆验证/权限控制）

​                                          7.任务：quartz（定时任务）邮件任务等（异步完成）

​                                          8.开发热部署（1.开发热部署  2.生产热部署）

​                                         9.日志系统

​                                         10.监管

​                                         11.tomcat等

3.持久层

​      ORM框架：mybaits、mybatisPlus、springData

​      Oracle/mysql

​                          1.sql查询优化（2）

​                          2.索引

​                          3.存储过程

​                          4.触发器                                